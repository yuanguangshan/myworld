[
  {
    "type": "file",
    "path": "g.html",
    "content": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ULW Minecraft 4.1 - Fast & Infinite</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }\n        \n        /* 准星 */\n        #crosshair {\n            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;\n            background: rgba(255,255,255,0.8);\n            clip-path: polygon(40% 0, 60% 0, 60% 40%, 100% 40%, 100% 60%, 60% 60%, 60% 100%, 40% 100%, 40% 60%, 0 60%, 0 40%, 40% 40%);\n            transform: translate(-50%, -50%); mix-blend-mode: exclusion; z-index: 100;\n        }\n\n        /* UI 层 */\n        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }\n        \n        /* 右侧背包按钮 */\n        #inv-toggle-btn {\n            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);\n            width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #fff;\n            border-radius: 10px; cursor: pointer; pointer-events: auto;\n            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;\n            transition: 0.2s;\n        }\n        #inv-toggle-btn:hover { background: rgba(0,0,0,0.8); scale: 1.1; }\n\n        /* 快捷栏 */\n        #hotbar {\n            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);\n            display: flex; gap: 8px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; pointer-events: auto;\n        }\n        .slot {\n            width: 50px; height: 50px; background: #3c3c3c; border: 3px solid #555;\n            display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer;\n            image-rendering: pixelated;\n        }\n        .slot.active { border-color: #fff; box-shadow: 0 0 8px white; transform: translateY(-2px); }\n        .slot img { width: 36px; height: 36px; image-rendering: pixelated; }\n        .slot .count { \n            position: absolute; bottom: 2px; right: 2px; color: white; \n            font-size: 14px; font-weight: bold; text-shadow: 2px 2px 0 #000; font-family: monospace;\n        }\n\n        /* 背包界面 */\n        #inventory-screen {\n            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);\n            width: 720px; height: 550px; background: #c6c6c6; border: 4px solid #333; pointer-events: auto;\n            box-shadow: 0 0 30px rgba(0,0,0,0.8); padding: 20px; border-radius: 4px;\n            color: #333;\n        }\n        \n        .panel-title { font-size: 18px; margin-bottom: 10px; font-weight: bold; border-bottom: 2px solid #777; padding-bottom: 5px; }\n\n        #crafting-area {\n            display: flex; gap: 10px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 15px;\n            background: #b0b0b0; padding: 10px; border-radius: 4px; box-shadow: inset 0 0 5px rgba(0,0,0,0.2);\n        }\n        .craft-item {\n            min-width: 64px; height: 80px; background: #8b8b8b; border: 2px solid #555; cursor: pointer;\n            display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;\n        }\n        .craft-item:hover { background: #9c9c9c; border-color: #fff; }\n        .craft-item.disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }\n\n        #inv-grid { \n            display: grid; grid-template-columns: repeat(10, 1fr); gap: 6px; \n            height: 320px; overflow-y: auto; background: #8b8b8b; padding: 10px; border: inset 3px #555;\n        }\n        \n        #stats { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 2px 2px 0 #000; font-family: monospace; }\n        \n        /* 提示 */\n        #message {\n            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);\n            font-size: 24px; color: #ffeb3b; text-shadow: 2px 2px 4px #000; \n            opacity: 0; transition: opacity 0.5s; pointer-events: none;\n        }\n    </style>\n</head>\n<body>\n\n<div id=\"crosshair\"></div>\n<div id=\"message\"></div>\n\n<div id=\"ui-layer\">\n    <div id=\"stats\">FPS: 60 | Y: 60</div>\n    <div id=\"inv-toggle-btn\" onclick=\"toggleInventory()\">背包<br>(E)</div>\n    <div id=\"hotbar\"></div>\n    <div id=\"inventory-screen\">\n        <div class=\"panel-title\">合成台 (点击图标合成)</div>\n        <div id=\"crafting-area\"></div>\n        <div class=\"panel-title\">物品栏 (64格 - 选中物品后点击快捷栏装备)</div>\n        <div id=\"inv-grid\"></div>\n        <button onclick=\"toggleInventory()\" style=\"margin-top:10px; padding:8px 30px; cursor:pointer; background:#555; color:white; border:2px solid #333;\">关闭</button>\n    </div>\n</div>\n\n<!-- Three.js 核心库 -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js\"></script>\n\n<script>\n    // --- 1. 游戏配置 (速度大幅提升) ---\n    const CONF = {\n        RENDER_DIST: 3,\n        CHUNK_SIZE: 16,\n        WORLD_BOTTOM: -64,\n        WORLD_TOP: 64,\n        SEA_LEVEL: 10,\n        GRAVITY: 30.0,\n        WALK_SPEED: 60.0,  // 基础行走速度提升 (原6.0)\n        RUN_SPEED: 110.0,  // 疾跑速度\n        JUMP: 13.0         // 跳跃高度略微提升\n    };\n\n    // 方块ID\n    const B = {\n        AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, BEDROCK: 4, LOG: 5, LEAVES: 6, PLANKS: 7,\n        COAL_ORE: 8, IRON_ORE: 9, DIAMOND_ORE: 10, GOLD_ORE: 11,\n        WATER: 12, LAVA: 13, SAND: 14, CRAFTING_TABLE: 15, COBBLESTONE: 16, BRICK: 17,\n        SWORD_WOOD: 100, SWORD_STONE: 101, SWORD_IRON: 102, SWORD_DIAMOND: 103, MEAT: 104\n    };\n\n    // --- 2. 纹理生成 ---\n    const iconCache = {};\n    const textures = {};\n\n    function generateTextureAndIcon(id, color, type = 'standard') {\n        const size = 64;\n        const canvas = document.createElement('canvas');\n        canvas.width = size; canvas.height = size;\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = color; ctx.fillRect(0,0,size,size);\n        for(let i=0; i<300; i++) {\n            ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n            const s = Math.ceil(Math.random()*3);\n            ctx.fillRect(Math.random()*size, Math.random()*size, s, s);\n        }\n        if(type === 'ore') {\n            ctx.fillStyle = '#000'; for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 10, 10);\n            ctx.fillStyle = color; for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 6, 6);\n            ctx.globalCompositeOperation = 'destination-over'; ctx.fillStyle = '#757575'; ctx.fillRect(0,0,size,size);\n        } else if (type === 'log') {\n            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;\n            for(let i=4; i<size; i+=10) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke(); }\n            ctx.fillStyle = '#5d4037'; ctx.fillRect(0,0,10,10);\n        } else if (type === 'brick' || type === 'cobble') {\n            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;\n            ctx.strokeRect(0,0,size,size); ctx.strokeRect(size/2, 0, size/2, size/2); ctx.strokeRect(0, size/2, size/2, size/2);\n        } else if (type === 'sword') {\n            ctx.clearRect(0,0,size,size);\n            ctx.fillStyle = '#4e342e'; ctx.fillRect(10,50, 15,15);\n            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(20,55); ctx.lineTo(55,20); ctx.lineTo(60,25); ctx.lineTo(25,60); ctx.fill();\n        } else if (type === 'meat') {\n            ctx.clearRect(0,0,size,size); ctx.fillStyle = '#e57373'; ctx.beginPath(); ctx.arc(32,32, 20, 0, Math.PI*2); ctx.fill();\n        }\n        iconCache[id] = canvas.toDataURL();\n        const tex = new THREE.CanvasTexture(canvas);\n        tex.magFilter = THREE.NearestFilter;\n        return tex;\n    }\n\n    const matCache = {};\n    const DEF = [\n        {id: B.GRASS, col:'#567d46', t:'standard'}, {id: B.DIRT, col:'#5d4037', t:'standard'},\n        {id: B.STONE, col:'#757575', t:'standard'}, {id: B.BEDROCK, col:'#111', t:'standard'},\n        {id: B.LOG, col:'#3e2723', t:'log'}, {id: B.LEAVES, col:'#2e7d32', t:'standard'},\n        {id: B.PLANKS, col:'#bcaaa4', t:'wood'}, {id: B.SAND, col:'#fff9c4', t:'standard'},\n        {id: B.WATER, col:'#2196f3', t:'standard', tr:true, op:0.6},\n        {id: B.LAVA, col:'#ff3d00', t:'standard', glow:true},\n        {id: B.COAL_ORE, col:'#212121', t:'ore'}, {id: B.IRON_ORE, col:'#d7ccc8', t:'ore'},\n        {id: B.DIAMOND_ORE, col:'#00bcd4', t:'ore'}, {id: B.GOLD_ORE, col:'#ffeb3b', t:'ore'},\n        {id: B.CRAFTING_TABLE, col:'#8d6e63', t:'brick'}, {id: B.COBBLESTONE, col:'#616161', t:'cobble'},\n        {id: B.SWORD_WOOD, col:'#8d6e63', t:'sword'}, {id: B.SWORD_STONE, col:'#757575', t:'sword'},\n        {id: B.SWORD_IRON, col:'#fff', t:'sword'}, {id: B.SWORD_DIAMOND, col:'#00bcd4', t:'sword'},\n        {id: B.MEAT, col:'#f48fb1', t:'meat'}\n    ];\n    DEF.forEach(d => {\n        const tex = generateTextureAndIcon(d.id, d.col, d.t);\n        if(d.id < 100) matCache[d.id] = new THREE.MeshLambertMaterial({ map: tex, transparent: d.tr, opacity: d.op||1, emissive: d.glow?d.col:0 });\n    });\n\n    // --- 3. 场景 ---\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x87CEEB);\n    scene.fog = new THREE.Fog(0x87CEEB, 20, CONF.RENDER_DIST * CONF.CHUNK_SIZE - 5);\n    // 增加一点 FOV 增加速度感\n    const camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer({antialias: false});\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n    scene.add(new THREE.AmbientLight(0xffffff, 0.4));\n    const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 100, 50); scene.add(sun);\n\n    // --- 4. 世界 ---\n    const worldData = {}; \n    const chunks = {};\n    const simplex = new SimplexNoise();\n\n    function getBiomeHeight(x, z) { return Math.floor(simplex.noise2D(x/100, z/100) * 20 + 30); }\n\n    function generateChunk(cx, cz) {\n        const forestNoise = (x,z) => simplex.noise2D(x/50, z/50) > 0.3;\n        for(let x=0; x<16; x++) {\n            for(let z=0; z<16; z++) {\n                const wx = cx*16 + x, wz = cz*16 + z;\n                const h = getBiomeHeight(wx, wz);\n                for(let y = CONF.WORLD_BOTTOM; y <= Math.max(h, CONF.SEA_LEVEL); y++) {\n                    let id = B.AIR;\n                    if(y === CONF.WORLD_BOTTOM) id = B.BEDROCK;\n                    else if (y < h - 4) {\n                        const cave = simplex.noise3D(wx/20, y/20, wz/20);\n                        if(cave > 0.6) id = (y < -10) ? B.LAVA : B.AIR;\n                        else {\n                            const r = Math.random();\n                            if(y<10 && r>0.99) id = B.DIAMOND_ORE;\n                            else if(y<30 && r>0.98) id = B.GOLD_ORE;\n                            else if(y<50 && r>0.97) id = B.IRON_ORE;\n                            else if(r>0.96) id = B.COAL_ORE;\n                            else id = B.STONE;\n                        }\n                    } else if (y < h) id = B.DIRT;\n                    else if (y === h) id = (y <= CONF.SEA_LEVEL) ? B.SAND : B.GRASS;\n                    else if (y <= CONF.SEA_LEVEL) id = B.WATER;\n                    if(id !== B.AIR) worldData[`${wx},${y},${wz}`] = id;\n                }\n                if(h > CONF.SEA_LEVEL && forestNoise(wx, wz) && Math.random() > 0.9) createTree(wx, h+1, wz);\n            }\n        }\n        if(Math.random() > 0.8) spawnEntity('pig', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);\n        if(Math.random() > 0.9) spawnEntity('zombie', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);\n    }\n\n    function createTree(x, y, z) {\n        for(let i=0; i<5; i++) worldData[`${x},${y+i},${z}`] = B.LOG;\n        for(let lx=-2; lx<=2; lx++) for(let lz=-2; lz<=2; lz++) for(let ly=3; ly<=5; ly++)\n            if(!worldData[`${x+lx},${y+ly},${z+lz}`]) worldData[`${x+lx},${y+ly},${z+lz}`] = B.LEAVES;\n    }\n\n    function updateChunkMesh(cx, cz) {\n        const key = `${cx},${cz}`;\n        if(chunks[key]) { scene.remove(chunks[key]); delete chunks[key]; }\n        const group = new THREE.Group();\n        const geometries = {}, matrices = {};\n        for(let x=0; x<16; x++) for(let z=0; z<16; z++) {\n            const wx = cx*16+x, wz = cz*16+z;\n            for(let y=CONF.WORLD_BOTTOM; y<=CONF.WORLD_TOP; y++) {\n                const id = worldData[`${wx},${y},${wz}`];\n                if(id && id!==B.AIR) {\n                    if(!geometries[id]) { geometries[id]=0; matrices[id]=[]; }\n                    matrices[id].push(new THREE.Matrix4().makeTranslation(wx, y, wz));\n                    geometries[id]++;\n                }\n            }\n        }\n        const boxGeo = new THREE.BoxGeometry(1,1,1);\n        for(let id in geometries) {\n            if(!matCache[id]) continue;\n            const mesh = new THREE.InstancedMesh(boxGeo, matCache[id], geometries[id]);\n            const arr = matrices[id];\n            for(let i=0; i<arr.length; i++) mesh.setMatrixAt(i, arr[i]);\n            group.add(mesh);\n        }\n        scene.add(group); chunks[key] = group;\n    }\n\n    // --- 5. 实体 ---\n    const entities = [];\n    const handGroup = new THREE.Group(); camera.add(handGroup); scene.add(camera);\n    const armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.8), new THREE.MeshLambertMaterial({color: 0xeebb99}));\n    armMesh.position.set(0.5, -0.4, -0.5); handGroup.add(armMesh);\n    const heldItemMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), matCache[B.DIRT]);\n    heldItemMesh.position.set(0.5, -0.3, -0.8); heldItemMesh.visible = false; handGroup.add(heldItemMesh);\n\n    function spawnEntity(type, x, y, z) {\n        const color = type==='zombie'?0x2e7d32 : 0xf48fb1;\n        const h = type==='zombie'?1.8:0.8;\n        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.6), new THREE.MeshLambertMaterial({color}));\n        mesh.position.set(x,y,z); scene.add(mesh);\n        entities.push({type, mesh, hp:10, vel:new THREE.Vector3(), timer:0});\n    }\n\n    // --- 6. 交互与UI ---\n    const player = { inv: new Array(64).fill(null), hotbar: [null,null,null,null,null], sel: 0 };\n    const controls = new THREE.PointerLockControls(camera, document.body);\n    const keys = {};\n    document.addEventListener('keydown', e => keys[e.code] = true);\n    document.addEventListener('keyup', e => keys[e.code] = false);\n\n    let isInvOpen = false, selectedInvIndex = -1;\n    function toggleInventory() {\n        isInvOpen = !isInvOpen;\n        document.getElementById('inventory-screen').style.display = isInvOpen ? 'block' : 'none';\n        if(isInvOpen) { controls.unlock(); renderInv(); } else controls.lock();\n    }\n\n    document.addEventListener('mousedown', e => {\n        if(isInvOpen || !controls.isLocked) { if(!isInvOpen) controls.lock(); return; }\n        handGroup.rotation.x = -0.5; setTimeout(()=>handGroup.rotation.x=0, 150);\n        if(e.button === 0) interact('break'); if(e.button === 2) interact('place');\n    });\n    \n    document.addEventListener('keydown', e => {\n        if(e.code === 'KeyE') toggleInventory();\n        if(e.key >= '1' && e.key <= '5') { player.sel = parseInt(e.key) - 1; updateHand(); renderHotbar(); }\n    });\n\n    function getLookingAt() {\n        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);\n        let pos = camera.position.clone();\n        for(let i=0; i<80; i++) {\n            pos.addScaledVector(dir, 0.06);\n            const x=Math.round(pos.x), y=Math.round(pos.y), z=Math.round(pos.z);\n            const id = worldData[`${x},${y},${z}`];\n            if(id && id!==B.AIR && id!==B.WATER) {\n                 const prev = pos.clone().addScaledVector(dir, -0.06);\n                 return {x,y,z, id, face:{x:Math.round(prev.x)-x, y:Math.round(prev.y)-y, z:Math.round(prev.z)-z}};\n            }\n        }\n        return null;\n    }\n\n    function interact(action) {\n        if(action === 'break') {\n            const hitEnt = entities.find(e => e.mesh.position.distanceTo(camera.position) < 3);\n            if(hitEnt) {\n                hitEnt.hp -= 2; hitEnt.mesh.material.emissive.setHex(0xff0000); setTimeout(()=>hitEnt.mesh.material.emissive.setHex(0), 100);\n                hitEnt.vel.y = 5; hitEnt.vel.add(new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3())).multiplyScalar(5));\n                if(hitEnt.hp<=0) { scene.remove(hitEnt.mesh); entities.splice(entities.indexOf(hitEnt),1); if(hitEnt.type==='pig') addToInv(B.MEAT, 2); }\n                return;\n            }\n        }\n        const hit = getLookingAt(); if(!hit) return;\n        if(action === 'break') {\n            if(hit.id === B.BEDROCK) return;\n            delete worldData[`${hit.x},${hit.y},${hit.z}`];\n            let drop = hit.id; if(hit.id===B.STONE) drop=B.COBBLESTONE; if(hit.id===B.GRASS) drop=B.DIRT; if(hit.id===B.LEAVES) drop=null;\n            if(drop) addToInv(drop, 1);\n            rebuild(hit.x, hit.z);\n        } else if (action === 'place') {\n            const idx = player.hotbar[player.sel]; if(idx===null || !player.inv[idx]) return;\n            const item = player.inv[idx]; if(item.id>=100) return;\n            const tx=hit.x+hit.face.x, ty=hit.y+hit.face.y, tz=hit.z+hit.face.z;\n            if(Math.abs(camera.position.x-tx)<0.6 && Math.abs(camera.position.y-ty)<1.8 && Math.abs(camera.position.z-tz)<0.6) return;\n            worldData[`${tx},${ty},${tz}`] = item.id;\n            item.count--; if(item.count<=0) player.inv[idx]=null;\n            renderHotbar(); updateHand(); rebuild(tx, tz);\n        }\n    }\n    \n    function rebuild(x, z) { updateChunkMesh(Math.floor(x/16), Math.floor(z/16)); }\n    function addToInv(id, num) {\n        for(let i=0; i<64; i++) if(player.inv[i] && player.inv[i].id===id && player.inv[i].count<64) { player.inv[i].count+=num; showMsg(`获得物品`); renderHotbar(); return; }\n        for(let i=0; i<64; i++) if(!player.inv[i]) { player.inv[i]={id, count:num}; showMsg(`获得物品`); renderHotbar(); updateHand(); return; }\n    }\n    function showMsg(m) { const el=document.getElementById('message'); el.innerText=m; el.style.opacity=1; setTimeout(()=>el.style.opacity=0,1500); }\n\n    const RECIPES = [\n        {out:B.PLANKS, n:4, in:{[B.LOG]:1}}, {out:B.CRAFTING_TABLE, n:1, in:{[B.PLANKS]:4}},\n        {out:B.SWORD_WOOD, n:1, in:{[B.PLANKS]:2}}, {out:B.SWORD_STONE, n:1, in:{[B.COBBLESTONE]:2}},\n        {out:B.SWORD_IRON, n:1, in:{[B.IRON_ORE]:2}}, {out:B.SWORD_DIAMOND, n:1, in:{[B.DIAMOND_ORE]:2}},\n        {out:B.BRICK, n:1, in:{[B.STONE]:1}}\n    ];\n    \n    function renderInv() {\n        const grid = document.getElementById('inv-grid'); grid.innerHTML='';\n        player.inv.forEach((item, i) => {\n            const el = document.createElement('div'); el.className='slot'+(selectedInvIndex===i?' active':'');\n            if(item) el.innerHTML = `<img src=\"${iconCache[item.id]}\"><span class=\"count\">${item.count}</span>`;\n            el.onclick = () => { selectedInvIndex=i; renderInv(); }; grid.appendChild(el);\n        });\n        const craft = document.getElementById('crafting-area'); craft.innerHTML='';\n        RECIPES.forEach(r => {\n            const div = document.createElement('div'); div.className='craft-item';\n            let enough = true;\n            for(let reqId in r.in) if(player.inv.reduce((s,it)=>s+(it&&it.id==reqId?it.count:0),0) < r.in[reqId]) enough=false;\n            if(!enough) div.classList.add('disabled');\n            div.innerHTML = `<img src=\"${iconCache[r.out]}\" width=\"40\"><span style=\"font-size:10px;font-weight:bold\">${r.n}</span>`;\n            div.onclick = () => {\n                if(!enough) return;\n                for(let reqId in r.in) {\n                    let cost=r.in[reqId];\n                    for(let i=0; i<64; i++) if(player.inv[i] && player.inv[i].id==reqId) {\n                        let take=Math.min(player.inv[i].count, cost); player.inv[i].count-=take; cost-=take;\n                        if(player.inv[i].count===0) player.inv[i]=null; if(cost<=0) break;\n                    }\n                }\n                addToInv(r.out, r.n); renderInv();\n            };\n            craft.appendChild(div);\n        });\n    }\n\n    function renderHotbar() {\n        const bar = document.getElementById('hotbar'); bar.innerHTML='';\n        for(let i=0; i<5; i++) {\n            const idx = player.hotbar[i]; const item = idx!==null?player.inv[idx]:null;\n            const el = document.createElement('div'); el.className='slot '+(player.sel===i?'active':'');\n            if(item) el.innerHTML = `<img src=\"${iconCache[item.id]}\"><span class=\"count\">${item.count}</span>`;\n            el.onclick=(e)=>{ e.stopPropagation(); if(isInvOpen && selectedInvIndex!==-1) { player.hotbar[i]=selectedInvIndex; selectedInvIndex=-1; renderInv(); renderHotbar(); updateHand(); } else { player.sel=i; renderHotbar(); updateHand(); }};\n            bar.appendChild(el);\n        }\n    }\n    \n    function updateHand() {\n        const idx=player.hotbar[player.sel], item=idx!==null?player.inv[idx]:null;\n        armMesh.visible = !item; heldItemMesh.visible = !!item;\n        if(item) {\n            heldItemMesh.geometry = item.id>=100 ? new THREE.BoxGeometry(0.1,0.6,0.1) : new THREE.BoxGeometry(0.4,0.4,0.4);\n            heldItemMesh.rotation.set(item.id>=100?Math.PI/4:0, 0, 0);\n            heldItemMesh.material = matCache[item.id] || new THREE.MeshBasicMaterial({color:0xffffff});\n        }\n    }\n\n    // --- 7. 循环与物理 ---\n    const clock = new THREE.Clock(); const vel = new THREE.Vector3();\n    let lastCx=-999, lastCz=-999, onGround=false;\n    camera.position.set(0, 50, 0);\n\n    function animate() {\n        requestAnimationFrame(animate);\n        const dt = Math.min(clock.getDelta(), 0.1);\n        if(controls.isLocked) {\n            vel.x -= vel.x * 10.0 * dt; vel.z -= vel.z * 10.0 * dt; vel.y -= CONF.GRAVITY * dt;\n            const dir = new THREE.Vector3();\n            const fwd = (keys['KeyW']?1:0)-(keys['KeyS']?1:0), side = (keys['KeyD']?1:0)-(keys['KeyA']?1:0);\n            dir.z = fwd; dir.x = side; dir.normalize();\n            \n            // 疾跑逻辑：按Shift加速\n            const currentSpeed = keys['ShiftLeft'] ? CONF.RUN_SPEED : CONF.WALK_SPEED;\n            if(fwd||side) { vel.z -= dir.z * currentSpeed * dt; vel.x -= dir.x * currentSpeed * dt; }\n            \n            controls.moveRight(-vel.x * dt); controls.moveForward(-vel.z * dt); camera.position.y += vel.y * dt;\n            \n            // 碰撞与自动跳跃\n            checkCollision();\n            if(keys['Space'] && onGround) vel.y = CONF.JUMP;\n            if(camera.position.y < CONF.WORLD_BOTTOM-10) { camera.position.set(0,60,0); vel.set(0,0,0); }\n        }\n\n        const cx = Math.floor(camera.position.x/16), cz = Math.floor(camera.position.z/16);\n        if(cx!==lastCx || cz!==lastCz) {\n            for(let x=-CONF.RENDER_DIST; x<=CONF.RENDER_DIST; x++) for(let z=-CONF.RENDER_DIST; z<=CONF.RENDER_DIST; z++) {\n                if(!chunks[`${cx+x},${cz+z}`]) { generateChunk(cx+x, cz+z); updateChunkMesh(cx+x, cz+z); }\n            }\n            for(let k in chunks) { const p=k.split(','); if(Math.abs(p[0]-cx)>CONF.RENDER_DIST+1 || Math.abs(p[1]-cz)>CONF.RENDER_DIST+1) { scene.remove(chunks[k]); delete chunks[k]; } }\n            lastCx=cx; lastCz=cz;\n        }\n\n        entities.forEach(ent => {\n            ent.vel.y -= CONF.GRAVITY * dt;\n            if(ent.type==='zombie' && ent.mesh.position.distanceTo(camera.position)<20) {\n                const d=camera.position.clone().sub(ent.mesh.position).normalize(); ent.vel.x=d.x*4; ent.vel.z=d.z*4;\n            } else if(Math.random()>0.98) { ent.vel.x=(Math.random()-0.5)*4; ent.vel.z=(Math.random()-0.5)*4; }\n            ent.mesh.position.addScaledVector(ent.vel, dt);\n            const ex=Math.round(ent.mesh.position.x), ey=Math.round(ent.mesh.position.y), ez=Math.round(ent.mesh.position.z);\n            if(worldData[`${ex},${ey},${ez}`] || worldData[`${ex},${ey-1},${ez}`]) { if(ent.vel.y<0) { ent.vel.y=0; ent.mesh.position.y=ey+1; } }\n        });\n\n        renderer.render(scene, camera);\n        document.getElementById('stats').innerText = `XYZ: ${Math.floor(camera.position.x)},${Math.floor(camera.position.y)},${Math.floor(camera.position.z)}`;\n    }\n\n    function checkCollision() {\n        const x=camera.position.x, y=camera.position.y, z=camera.position.z;\n        const bx=Math.round(x), by=Math.round(y-1.6), bz=Math.round(z);\n        // 自动跳跃\n        const dir=new THREE.Vector3(); camera.getWorldDirection(dir);\n        if(onGround && keys['KeyW'] && worldData[`${Math.round(x+dir.x)},${Math.round(y-1)},${Math.round(z+dir.z)}`] && !worldData[`${Math.round(x+dir.x)},${Math.round(y)},${Math.round(z+dir.z)}`]) vel.y=6;\n        \n        let hitY = -999;\n        for(let k=0; k<=2; k++) if(worldData[`${bx},${by-k},${bz}`] && worldData[`${bx},${by-k},${bz}`]!==B.AIR) { hitY=by-k; break; }\n        if(y < hitY+2.6) { camera.position.y=hitY+2.6; vel.y=0; onGround=true; } else onGround=false;\n    }\n\n    updateHand(); renderHotbar(); animate();\n    window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };\n</script>\n</body>\n</html>",
    "tokens": 6361
  },
  {
    "type": "file",
    "path": "/Users/ygs/myworld/src/main.ts",
    "content": "import * as THREE from 'three';\nimport { Game as Game } from './chunkManager';\nimport { Player } from './player';\nimport { BLOCK_NAMES, BlockType, WORLD_SIZE } from './types';\n\nexport class MyWorldGame {\n  private scene: THREE.Scene;\n  private camera: THREE.PerspectiveCamera;\n  private renderer: THREE.WebGLRenderer;\n  private chunkManager: Game;\n  private player: Player;\n  private raycaster: THREE.Raycaster;\n  private selectedBlock: BlockType = 'grass';\n  private isRunning: boolean = false;\n  private lastTime: number = 0;\n  private frameCount: number = 0;\n  private lastFpsUpdate: number = 0;\n  private stats: WorldStats = {\n    blocksPlaced: 0,\n    blocksBroken: 0\n  };\n\n  constructor() {\n    this.init();\n    this.setupUI();\n    this.animate();\n  }\n\n  private init() {\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(0x87CEEB);\n    this.scene.fog = new THREE.Fog(0x87CEEB, 50, WORLD_SIZE * 2);\n\n    this.camera = new THREE.PerspectiveCamera(\n      75,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      1000\n    );\n\n    this.renderer = new THREE.WebGLRenderer({ antialias: false });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    document.getElementById('game-container')?.appendChild(this.renderer.domElement);\n\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n    this.scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(50, 100, 50);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 2048;\n    directionalLight.shadow.mapSize.height = 2048;\n    directionalLight.shadow.camera.near = 0.5;\n    directionalLight.shadow.camera.far = 500;\n    directionalLight.shadow.camera.left = -WORLD_SIZE;\n    directionalLight.shadow.camera.right = WORLD_SIZE;\n    directionalLight.shadow.camera.top = WORLD_SIZE;\n    directionalLight.shadow.camera.bottom = -WORLD_SIZE;\n    this.scene.add(directionalLight);\n\n    this.chunkManager = new Game(this.scene);\n\n    this.player = new Player(this.camera, { x: 0, y: 50, z: 0 });\n\n    this.raycaster = new THREE.Raycaster();\n    this.raycaster.far = 6;\n\n    window.addEventListener('resize', () => this.onWindowResize());\n    document.addEventListener('mousedown', (e) => this.onMouseDown(e));\n\n    const loading = document.getElementById('loading');\n    if (loading) loading.style.display = 'none';\n  }\n\n  private setupUI() {\n    const startBtn = document.getElementById('start-btn');\n    if (startBtn) {\n      startBtn.addEventListener('click', () => {\n        const instructions = document.getElementById('instructions');\n        if (instructions) instructions.style.display = 'none';\n        this.isRunning = true;\n        document.body.requestPointerLock();\n      });\n    }\n  }\n\n  private onMouseDown(e: MouseEvent) {\n    if (!this.isRunning) return;\n\n    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);\n    const target = this.chunkManager.getRaycastTarget(this.camera, this.raycaster);\n\n    if (target) {\n      const { block, face } = target;\n\n      if (e.button === 0) {\n        this.chunkManager.removeBlock(block.x, block.y, block.z);\n      } else if (e.button === 2) {\n        const newX = block.x + Math.round(face.x);\n        const newY = block.y + Math.round(face.y);\n        const newZ = block.z + Math.round(face.z);\n\n        const playerPos = this.player.getPosition();\n        const distance = Math.sqrt(\n          Math.pow(newX - playerPos.x, 2) +\n            Math.pow(newY - (playerPos.y + 0.9), 2) +\n            Math.pow(newZ - playerPos.z, 2)\n        );\n\n        if (distance > 1.5) {\n          this.chunkManager.addBlock(newX, newY, newZ, this.selectedBlock);\n        }\n      }\n    }\n  }\n\n  private onWindowResize() {\n    this.camera.aspect = window.innerWidth / window.innerHeight;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n  private updateUI(delta: number) {\n    this.frameCount++;\n\n    if (performance.now() - this.lastFpsUpdate >= 1000) {\n      const fps = this.frameCount;\n      const fpsElement = document.getElementById('fps');\n      if (fpsElement) fpsElement.textContent = fps.toString();\n\n      this.frameCount = 0;\n      this.lastFpsUpdate = performance.now();\n    }\n\n    const pos = this.player.getPosition();\n    const stats = this.chunkManager.getStats();\n    const posElement = document.getElementById('position');\n    if (posElement) {\n      posElement.textContent = `X: ${Math.floor(pos.x)} Y: ${Math.floor(pos.y)} Z: ${Math.floor(pos.z)}`;\n    }\n\n    const statsElement = document.getElementById('stats');\n    if (statsElement) {\n      statsElement.innerHTML = `Placed: ${stats.blocksPlaced} | Broken: ${stats.blocksBroken}`;\n    }\n  }\n\n  private animate() {\n    requestAnimationFrame(() => this.animate());\n\n    const currentTime = performance.now();\n    const delta = (currentTime - this.lastTime) / 1000;\n    this.lastTime = currentTime;\n\n    if (this.isRunning) {\n      this.player.update(delta, this.chunkManager);\n      this.chunkManager.update(this.player.getPosition());\n    }\n\n    this.renderer.render(this.scene, this.camera);\n    this.updateUI(delta);\n  }\n}\n\nnew MyWorldGame();\n",
    "tokens": 1340
  },
  {
    "type": "file",
    "path": "/Users/ygs/myworld/src/player.ts",
    "content": "import * as THREE from 'three';\nimport { GRAVITY, JUMP_FORCE, MOVE_SPEED, MOUSE_SENSITIVITY, PlayerState, RUN_MULTIPLIER } from './types';\n\nexport class Player {\n  private camera: THREE.PerspectiveCamera;\n  private state: PlayerState;\n  private keys: Map<string, boolean>;\n  private isLocked: boolean;\n\n  constructor(camera: THREE.PerspectiveCamera, startPosition = { x: 0, y: 10, z: 0 }) {\n    this.camera = camera;\n    this.keys = new Map();\n    this.isLocked = false;\n\n    this.state = {\n      position: { ...startPosition },\n      rotation: { x: 0, y: 0 },\n      velocity: { x: 0, y: 0, z: 0 },\n      onGround: false,\n    };\n\n    this.setupEventListeners();\n    this.updateCamera();\n  }\n\n  private setupEventListeners() {\n    document.addEventListener('keydown', (e) => {\n      this.keys.set(e.code, true);\n\n      if (e.code === 'Space' && this.state.onGround) {\n        this.state.velocity.y = JUMP_FORCE;\n        this.state.onGround = false;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      this.keys.set(e.code, false);\n    });\n\n    document.addEventListener('mousemove', (e) => {\n      if (this.isLocked) {\n        this.state.rotation.y -= e.movementX * MOUSE_SENSITIVITY;\n        this.state.rotation.x -= e.movementY * MOUSE_SENSITIVITY;\n\n        this.state.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.state.rotation.x));\n\n        this.updateCamera();\n      }\n    });\n\n    document.addEventListener('pointerlockchange', () => {\n      this.isLocked = document.pointerLockElement === document.body;\n    });\n\n    document.addEventListener('click', () => {\n      if (!this.isLocked) {\n        document.body.requestPointerLock();\n      }\n    });\n  }\n\n  private updateCamera() {\n    this.camera.position.set(\n      this.state.position.x,\n      this.state.position.y + 1.6,\n      this.state.position.z\n    );\n\n    this.camera.rotation.order = 'YXZ';\n    this.camera.rotation.y = this.state.rotation.y;\n    this.camera.rotation.x = this.state.rotation.x;\n  }\n\n  getDirection(): THREE.Vector3 {\n    const direction = new THREE.Vector3();\n\n    if (this.keys.get('KeyW')) direction.z -= 1;\n    if (this.keys.get('KeyS')) direction.z += 1;\n    if (this.keys.get('KeyA')) direction.x -= 1;\n    if (this.keys.get('KeyD')) direction.x += 1;\n\n    direction.normalize();\n    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.state.rotation.y);\n\n    return direction;\n  }\n\n  getCurrentSpeed(): number {\n    const isSprinting = this.keys.get('ShiftLeft') || this.keys.get('ShiftRight');\n    return isSprinting ? MOVE_SPEED * RUN_MULTIPLIER : MOVE_SPEED;\n  }\n\n  update(delta: number, world: any) {\n    this.state.velocity.y += GRAVITY * delta;\n\n    const direction = this.getDirection();\n    const speed = this.getCurrentSpeed();\n    this.state.velocity.x = direction.x * speed;\n    this.state.velocity.z = direction.z * speed;\n\n    const newX = this.state.position.x + this.state.velocity.x * delta;\n    const newY = this.state.position.y + this.state.velocity.y * delta;\n    const newZ = this.state.position.z + this.state.velocity.z * delta;\n\n    if (!this.checkCollision(newX, this.state.position.y, this.state.position.z, world)) {\n      this.state.position.x = newX;\n    } else {\n      this.state.velocity.x = 0;\n    }\n\n    if (!this.checkCollision(this.state.position.x, newY, this.state.position.z, world)) {\n      this.state.position.y = newY;\n      this.state.velocity.y *= 0.99;\n    } else {\n      if (this.state.velocity.y < 0) {\n        this.state.onGround = true;\n      }\n      this.state.velocity.y = 0;\n    }\n\n    if (!this.checkCollision(this.state.position.x, this.state.position.y, newZ, world)) {\n      this.state.position.z = newZ;\n    } else {\n      this.state.velocity.z = 0;\n    }\n\n    if (this.state.position.y < -10) {\n      this.state.position.y = 10;\n      this.state.velocity.y = 0;\n    }\n\n    this.updateCamera();\n  }\n\n  private checkCollision(x: number, y: number, z: number, world: any): boolean {\n    const playerHeight = 1.8;\n    const playerRadius = 0.3;\n\n    const checkPoints = [\n      { x, y: y + 0.5, z },\n      { x, y: y + 1.0, z },\n      { x, y: y + 1.5, z },\n    ];\n\n    for (const point of checkPoints) {\n      for (let dx = -playerRadius; dx <= playerRadius; dx += playerRadius * 2) {\n        for (let dz = -playerRadius; dz <= playerRadius; dz += playerRadius * 2) {\n          const bx = Math.floor(point.x + dx);\n          const by = Math.floor(point.y);\n          const bz = Math.floor(point.z + dz);\n\n          if (world.getBlockAt(bx, by, bz)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  getPosition(): { x: number; y: number; z: number } {\n    return { ...this.state.position };\n  }\n\n  getRotation(): { x: number; y: number } {\n    return { ...this.state.rotation };\n  }\n}\n",
    "tokens": 1202
  },
  {
    "type": "file",
    "path": "/Users/ygs/myworld/src/types.ts",
    "content": "export interface Vector3Like {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface Block {\n  x: number;\n  y: number;\n  z: number;\n  type: BlockType;\n}\n\nexport type BlockType = 'grass' | 'dirt' | 'stone' | 'wood' | 'leaves' | 'sand' | 'water';\n\nexport interface BlockColor {\n  top: number;\n  side: number;\n  bottom: number;\n}\n\nexport interface WorldStats {\n  blocksPlaced: number;\n  blocksBroken: number;\n}\n\nexport interface PlayerState {\n  position: { x: number; y: number; z: number };\n  rotation: { x: number; y: number };\n  velocity: { x: number; y: number; z: number };\n  onGround: boolean;\n}\n\nexport const BLOCK_COLORS: Record<BlockType, BlockColor> = {\n  grass: { top: 0x7CFC00, side: 0x8B4513, bottom: 0x8B4513 },\n  dirt: { top: 0x8B4513, side: 0x8B4513, bottom: 0x8B4513 },\n  stone: { top: 0x808080, side: 0x808080, bottom: 0x808080 },\n  wood: { top: 0x8B6914, side: 0x654321, bottom: 0x8B6914 },\n  leaves: { top: 0x228B22, side: 0x228B22, bottom: 0x228B22 },\n  sand: { top: 0xF4A460, side: 0xF4A460, bottom: 0xF4A460 },\n  water: { top: 0x4169E1, side: 0x4169E1, bottom: 0x4169E1 },\n};\n\nexport const BLOCK_NAMES: Record<BlockType, string> = {\n  grass: '草地',\n  dirt: '泥土',\n  stone: '石头',\n  wood: '木头',\n  leaves: '树叶',\n  sand: '沙子',\n  water: '水',\n};\n\nexport const WORLD_SIZE = 32;\nexport const CHUNK_SIZE = 16;\nexport const BLOCK_SIZE = 1;\nexport const GRAVITY = -30;\nexport const JUMP_FORCE = 10;\nexport const MOVE_SPEED = 5;\nexport const RUN_MULTIPLIER = 1.5;\nexport const MOUSE_SENSITIVITY = 0.002;\n",
    "tokens": 379
  },
  {
    "type": "file",
    "path": "src/chunkManager.ts",
    "content": "import * as THREE from 'three';\nimport { BLOCK_COLORS, Block, BlockType, Vector3Like, WorldStats, WORLD_SIZE } from './types';\n\nexport interface ChunkKey {\n  x: number;\n  z: number;\n}\n\nexport interface ChunkData {\n  blocks: Map<string, Block>;\n  mesh?: THREE.InstancedMesh;\n  position: { x: number; z: number };\n}\n\n  export class ChunkManager {\n  private scene: THREE.Scene;\n  private chunks: Map<string, ChunkData>;\n  private blockGeometries: Map<BlockType, THREE.BoxGeometry>;\n  private blockMaterials: Map<BlockType, THREE.Material[]>;\n  private lastChunkX: number = 0;\n  private lastChunkZ: number = 0;\n  private geometry: THREE.BoxGeometry;\n  private worldStats: WorldStats = {\n    blocksPlaced: 0,\n    blocksBroken: 0,\n  };\n\n  private createMaterials() {\n    this.blockMaterials = new Map();\n\n    for (const [blockType, colors] of Object.entries(BLOCK_COLORS)) {\n      const materials = [\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.top }),\n        new THREE.MeshLambertMaterial({ color: colors.bottom }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n      ];\n      this.blockMaterials.set(blockType as BlockType, materials);\n    }\n  }\n\n  private createBlockGeometries() {\n    this.blockGeometries = new Map();\n\n    const blockTypes: BlockType[] = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand'];\n\n    for (const type of blockTypes) {\n      const geo = new THREE.BoxGeometry(1, 1, 1);\n      this.blockGeometries.set(type, geo);\n    }\n  }\n\n  private getChunkKey(cx: number, cz: number): string {\n    return `${cx},${cz}`;\n  }\n\n  getChunkData(worldX: number, worldZ: number): ChunkData | null {\n    const cx = Math.floor(worldX / CHUNK_SIZE);\n    const cz = Math.floor(worldZ / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    if (!this.chunks.has(key)) {\n      return null;\n    }\n\n    return this.chunks.get(key) || null;\n  }\n\n  addBlock(x: number, y: number, z: number, type: BlockType) {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    let chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      chunkData = {\n        blocks: new Map(),\n        position: { x: cx * CHUNK_SIZE, z: cz * CHUNK_SIZE },\n      };\n      this.chunks.set(key, chunkData);\n    }\n\n    const blockKey = `${x},${y},${z}`;\n    chunkData.blocks.set(blockKey, { x, y, z, type });\n    this.worldStats.blocksPlaced++;\n\n    this.rebuildChunkMesh(cx, cz);\n    this.updateNeighborChunks(cx, cz);\n  }\n\n  removeBlock(x: number, y: number, z: number): boolean {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n    const blockKey = `${x},${y},${z}`;\n\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData || !chunkData.blocks.has(blockKey)) {\n      return false;\n    }\n\n    chunkData.blocks.delete(blockKey);\n    this.worldStats.blocksBroken++;\n\n    this.rebuildChunkMesh(cx, cz);\n    this.updateNeighborChunks(cx, cz);\n\n    return true;\n  }\n\n  private rebuildChunkMesh(cx: number, cz: number) {\n    const key = this.getChunkKey(cx, cz);\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      return;\n    }\n\n    if (chunkData.mesh) {\n      this.scene.remove(chunkData.mesh);\n    }\n\n    const instancesByType = new Map<BlockType, { count: number; matrices: THREE.Matrix4[] }>();\n\n    for (const [_, block] of chunkData.blocks) {\n      if (!instancesByType.has(block.type)) {\n        instancesByType.set(block.type, { count: 0, matrices: [] });\n      }\n\n      const instanceData = instancesByType.get(block.type)!;\n      instanceData.count++;\n      instanceData.matrices.push(new THREE.Matrix4().makeTranslation(block.x, block.y, block.z));\n    }\n\n    const group = new THREE.Group();\n\n    for (const [blockType, data] of instancesByType) {\n      if (data.count === 0) continue;\n\n      const geometry = this.blockGeometries.get(blockType);\n      const materials = this.blockMaterials.get(blockType);\n\n      if (!geometry || !materials) continue;\n\n      const instancedMesh = new THREE.InstancedMesh(geometry, materials, data.count);\n\n      for (let i = 0; i < data.count; i++) {\n        instancedMesh.setMatrixAt(i, data.matrices[i]);\n      }\n\n      instancedMesh.instanceMatrix.needsUpdate = true;\n      instancedMesh.castShadow = true;\n      instancedMesh.receiveShadow = true;\n\n      group.add(instancedMesh);\n    }\n\n    this.scene.add(group);\n    chunkData.mesh = group as any;\n  }\n\n  private updateNeighborChunks(cx: number, cz: number) {\n    const directions = [\n      [1, 0], [-1, 0], [0, 1], [0, -1],\n    ];\n\n    for (const [dx, dz] of directions) {\n      const neighborKey = this.getChunkKey(cx + dx, cz + dz);\n\n      if (this.chunks.has(neighborKey)) {\n        this.rebuildChunkMesh(cx + dx, cz + dz);\n      }\n    }\n  }\n\n  private generateChunk(cx: number, cz: number) {\n    const key = this.getChunkKey(cx, cz);\n    const chunkData: ChunkData = {\n      blocks: new Map(),\n      position: { x: cx * CHUNK_SIZE, z: cz * CHUNK_SIZE },\n    };\n\n    const offsetX = cx * CHUNK_SIZE;\n    const offsetZ = cz * CHUNK_SIZE;\n\n    for (let x = 0; x < CHUNK_SIZE; x++) {\n      for (let z = 0; z < CHUNK_SIZE; z++) {\n        const wx = offsetX + x;\n        const wz = offsetZ + z;\n\n        const height = Math.floor(\n          Math.sin(wx * 0.05) * 3 +\n            Math.cos(wz * 0.05) * 3 +\n            Math.sin(wx * 0.03 + wz * 0.03) * 5 + 5\n        );\n\n        for (let y = 0; y <= height; y++) {\n          let blockType: BlockType;\n\n          if (y === height) {\n            blockType = 'grass';\n          } else if (y > height - 3) {\n            blockType = 'dirt';\n          } else {\n            blockType = 'stone';\n          }\n\n          chunkData.blocks.set(`${wx},${y},${wz}`, { x: wx, y, z: wz, type: blockType });\n        }\n\n        if (x % 8 === 0 && z % 8 === 0 && Math.random() > 0.7) {\n          this.generateTree(chunkData, wx, height + 1, wz);\n        }\n      }\n    }\n\n    this.chunks.set(key, chunkData);\n    this.rebuildChunkMesh(cx, cz);\n  }\n\n  private generateTree(chunkData: ChunkData, x: number, y: number, z: number) {\n    for (let i = 0; i < 4; i++) {\n      chunkData.blocks.set(`${x},${y + i},${z}`, { x, y: y + i, z, type: 'wood' });\n    }\n\n    for (let dx = -2; dx <= 2; dx++) {\n      for (let dz = -2; dz <= 2; dz++) {\n        for (let dy = 0; dy <= 2; dy++) {\n          if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;\n          if (dy === 2 && (Math.abs(dx) > 1 || Math.abs(dz) > 1)) continue;\n          if (dx === 0 && dz === 0 && dy < 2) continue;\n\n          chunkData.blocks.set(`${x + dx},${y + 4 + dy},${z + dz}`, {\n            x: x + dx,\n            y: y + 4 + dy,\n            z: z + dz,\n            type: 'leaves',\n          });\n        }\n      }\n    }\n  }\n\n  getBlockAt(x: number, y: number, z: number): Block | null {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      return null;\n    }\n\n    const blockKey = `${x},${y},${z}`;\n    return chunkData.blocks.get(blockKey) || null;\n  }\n\n  getRaycastTarget(camera: THREE.Camera, raycaster: THREE.Raycaster): { block: Block; face: THREE.Vector3 } | null {\n    const allMeshes: THREE.InstancedMesh[] = [];\n\n    for (const [_, chunk] of this.chunks) {\n      if (chunk.mesh) {\n        allMeshes.push(...chunk.mesh.children as THREE.InstancedMesh[]);\n      }\n    }\n\n    const intersects = raycaster.intersectObjects(allMeshes);\n\n    if (intersects.length > 0) {\n      const hit = intersects[0];\n      const matrix = new THREE.Matrix4();\n\n      const instancedMesh = hit.object as THREE.InstancedMesh;\n      const instanceId = hit.instanceId || 0;\n      instancedMesh.getMatrixAt(instanceId, matrix);\n\n      const position = new THREE.Vector3();\n      position.setFromMatrixPosition(matrix);\n\n      const chunkData = this.getChunkData(position.x, position.z);\n\n      if (chunkData) {\n        const blockKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;\n        const actualBlock = chunkData.blocks.get(blockKey);\n        if (actualBlock) {\n          return {\n            block: {\n              x: Math.round(position.x),\n              y: Math.round(position.y),\n              z: Math.round(position.z),\n              type: actualBlock.type,\n            },\n            face: hit.face.normal,\n          };\n        }\n      }\n\n      return null;\n    }\n\n  update(playerPosition: { x: number; z: number }) {\n    const cx = Math.floor(playerPosition.x / CHUNK_SIZE);\n    const cz = Math.floor(playerPosition.z / CHUNK_SIZE);\n\n    if (cx !== this.lastChunkX || cz !== this.lastChunkZ) {\n      this.lastChunkX = cx;\n      this.lastChunkZ = cz;\n\n      const renderDist = 3;\n\n      for (let dx = -renderDist; dx <= renderDist; dx++) {\n        for (let dz = -renderDist; dz <= renderDist; dz++) {\n          const key = this.getChunkKey(cx + dx, cz + dz);\n\n          if (!this.chunks.has(key)) {\n            this.generateChunk(cx + dx, cz + dz);\n          }\n        }\n      }\n\n      const keysToDelete: string[] = [];\n\n      this.chunks.forEach((chunk, key) => {\n        const [kx, kz] = key.split(',').map(Number);\n        const dist = Math.max(Math.abs(kx - cx), Math.abs(kz - cz));\n\n        if (dist > renderDist + 1) {\n          keysToDelete.push(key);\n        }\n      });\n\n      for (const key of keysToDelete) {\n        const chunk = this.chunks.get(key);\n\n        if (chunk && chunk.mesh) {\n          this.scene.remove(chunk.mesh);\n        }\n\n        this.chunks.delete(key);\n      }\n    }\n\n    return { ...this.worldStats };\n  }\n        }\n      }\n\n      const keysToDelete: string[] = [];\n\n      this.chunks.forEach((chunk, key) => {\n        const [kx, kz] = key.split(',').map(Number);\n        const dist = Math.max(Math.abs(kx - cx), Math.abs(kz - cz));\n\n        if (dist > renderDist + 1) {\n          keysToDelete.push(key);\n        }\n      });\n\n      for (const key of keysToDelete) {\n        const chunk = this.chunks.get(key);\n\n        if (chunk && chunk.mesh) {\n          this.scene.remove(chunk.mesh);\n        }\n\n        this.chunks.delete(key);\n      }\n    }\n  }\n\n  getStats(): WorldStats {\n    return { ...this.worldStats };\n  }\n\n  dispose() {\n    this.blockMaterials.forEach((materials) => {\n      materials.forEach((material) => material.dispose());\n    });\n\n    this.blockGeometries.forEach((geometry) => {\n      geometry.dispose();\n    });\n\n    this.geometry.dispose();\n\n    for (const [_, chunk] of this.chunks) {\n      if (chunk.mesh) {\n        this.scene.remove(chunk.mesh);\n      }\n    }\n\n    this.chunks.clear();\n  }\n}\n",
    "tokens": 2726
  },
  {
    "type": "file",
    "path": "src/chunkManager.ts",
    "content": "import * as THREE from 'three';\nimport { BLOCK_COLORS, Block, BlockType, Vector3Like, WorldStats, WORLD_SIZE } from './types';\n\nexport interface ChunkKey {\n  x: number;\n  z: number;\n}\n\nexport interface ChunkData {\n  blocks: Map<string, Block>;\n  mesh?: THREE.InstancedMesh;\n  position: { x: number; z: number };\n}\n\n  export class ChunkManager {\n  private scene: THREE.Scene;\n  private chunks: Map<string, ChunkData>;\n  private blockGeometries: Map<BlockType, THREE.BoxGeometry>;\n  private blockMaterials: Map<BlockType, THREE.Material[]>;\n  private lastChunkX: number = 0;\n  private lastChunkZ: number = 0;\n  private geometry: THREE.BoxGeometry;\n  private worldStats: WorldStats = {\n    blocksPlaced: 0,\n    blocksBroken: 0,\n  };\n\n  private createMaterials() {\n    this.blockMaterials = new Map();\n\n    for (const [blockType, colors] of Object.entries(BLOCK_COLORS)) {\n      const materials = [\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.top }),\n        new THREE.MeshLambertMaterial({ color: colors.bottom }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n      ];\n      this.blockMaterials.set(blockType as BlockType, materials);\n    }\n  }\n\n  private createBlockGeometries() {\n    this.blockGeometries = new Map();\n\n    const blockTypes: BlockType[] = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand'];\n\n    for (const type of blockTypes) {\n      const geo = new THREE.BoxGeometry(1, 1, 1);\n      this.blockGeometries.set(type, geo);\n    }\n  }\n\n  private getChunkKey(cx: number, cz: number): string {\n    return `${cx},${cz}`;\n  }\n\n  getChunkData(worldX: number, worldZ: number): ChunkData | null {\n    const cx = Math.floor(worldX / CHUNK_SIZE);\n    const cz = Math.floor(worldZ / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    if (!this.chunks.has(key)) {\n      return null;\n    }\n\n    return this.chunks.get(key) || null;\n  }\n\n  addBlock(x: number, y: number, z: number, type: BlockType) {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    let chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      chunkData = {\n        blocks: new Map(),\n        position: { x: cx * CHUNK_SIZE, z: cz * CHUNK_SIZE },\n      };\n      this.chunks.set(key, chunkData);\n    }\n\n    const blockKey = `${x},${y},${z}`;\n    chunkData.blocks.set(blockKey, { x, y, z, type });\n    this.worldStats.blocksPlaced++;\n\n    this.rebuildChunkMesh(cx, cz);\n    this.updateNeighborChunks(cx, cz);\n  }\n\n  removeBlock(x: number, y: number, z: number): boolean {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n    const blockKey = `${x},${y},${z}`;\n\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData || !chunkData.blocks.has(blockKey)) {\n      return false;\n    }\n\n    chunkData.blocks.delete(blockKey);\n    this.worldStats.blocksBroken++;\n\n    this.rebuildChunkMesh(cx, cz);\n    this.updateNeighborChunks(cx, cz);\n\n    return true;\n  }\n\n  private rebuildChunkMesh(cx: number, cz: number) {\n    const key = this.getChunkKey(cx, cz);\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      return;\n    }\n\n    if (chunkData.mesh) {\n      this.scene.remove(chunkData.mesh);\n    }\n\n    const instancesByType = new Map<BlockType, { count: number; matrices: THREE.Matrix4[] }>();\n\n    for (const [_, block] of chunkData.blocks) {\n      if (!instancesByType.has(block.type)) {\n        instancesByType.set(block.type, { count: 0, matrices: [] });\n      }\n\n      const instanceData = instancesByType.get(block.type)!;\n      instanceData.count++;\n      instanceData.matrices.push(new THREE.Matrix4().makeTranslation(block.x, block.y, block.z));\n    }\n\n    const group = new THREE.Group();\n\n    for (const [blockType, data] of instancesByType) {\n      if (data.count === 0) continue;\n\n      const geometry = this.blockGeometries.get(blockType);\n      const materials = this.blockMaterials.get(blockType);\n\n      if (!geometry || !materials) continue;\n\n      const instancedMesh = new THREE.InstancedMesh(geometry, materials, data.count);\n\n      for (let i = 0; i < data.count; i++) {\n        instancedMesh.setMatrixAt(i, data.matrices[i]);\n      }\n\n      instancedMesh.instanceMatrix.needsUpdate = true;\n      instancedMesh.castShadow = true;\n      instancedMesh.receiveShadow = true;\n\n      group.add(instancedMesh);\n    }\n\n    this.scene.add(group);\n    chunkData.mesh = group as any;\n  }\n\n  private updateNeighborChunks(cx: number, cz: number) {\n    const directions = [\n      [1, 0], [-1, 0], [0, 1], [0, -1],\n    ];\n\n    for (const [dx, dz] of directions) {\n      const neighborKey = this.getChunkKey(cx + dx, cz + dz);\n\n      if (this.chunks.has(neighborKey)) {\n        this.rebuildChunkMesh(cx + dx, cz + dz);\n      }\n    }\n  }\n\n  private generateChunk(cx: number, cz: number) {\n    const key = this.getChunkKey(cx, cz);\n    const chunkData: ChunkData = {\n      blocks: new Map(),\n      position: { x: cx * CHUNK_SIZE, z: cz * CHUNK_SIZE },\n    };\n\n    const offsetX = cx * CHUNK_SIZE;\n    const offsetZ = cz * CHUNK_SIZE;\n\n    for (let x = 0; x < CHUNK_SIZE; x++) {\n      for (let z = 0; z < CHUNK_SIZE; z++) {\n        const wx = offsetX + x;\n        const wz = offsetZ + z;\n\n        const height = Math.floor(\n          Math.sin(wx * 0.05) * 3 +\n            Math.cos(wz * 0.05) * 3 +\n            Math.sin(wx * 0.03 + wz * 0.03) * 5 + 5\n        );\n\n        for (let y = 0; y <= height; y++) {\n          let blockType: BlockType;\n\n          if (y === height) {\n            blockType = 'grass';\n          } else if (y > height - 3) {\n            blockType = 'dirt';\n          } else {\n            blockType = 'stone';\n          }\n\n          chunkData.blocks.set(`${wx},${y},${wz}`, { x: wx, y, z: wz, type: blockType });\n        }\n\n        if (x % 8 === 0 && z % 8 === 0 && Math.random() > 0.7) {\n          this.generateTree(chunkData, wx, height + 1, wz);\n        }\n      }\n    }\n\n    this.chunks.set(key, chunkData);\n    this.rebuildChunkMesh(cx, cz);\n  }\n\n  private generateTree(chunkData: ChunkData, x: number, y: number, z: number) {\n    for (let i = 0; i < 4; i++) {\n      chunkData.blocks.set(`${x},${y + i},${z}`, { x, y: y + i, z, type: 'wood' });\n    }\n\n    for (let dx = -2; dx <= 2; dx++) {\n      for (let dz = -2; dz <= 2; dz++) {\n        for (let dy = 0; dy <= 2; dy++) {\n          if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;\n          if (dy === 2 && (Math.abs(dx) > 1 || Math.abs(dz) > 1)) continue;\n          if (dx === 0 && dz === 0 && dy < 2) continue;\n\n          chunkData.blocks.set(`${x + dx},${y + 4 + dy},${z + dz}`, {\n            x: x + dx,\n            y: y + 4 + dy,\n            z: z + dz,\n            type: 'leaves',\n          });\n        }\n      }\n    }\n  }\n\n  getBlockAt(x: number, y: number, z: number): Block | null {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      return null;\n    }\n\n    const blockKey = `${x},${y},${z}`;\n    return chunkData.blocks.get(blockKey) || null;\n  }\n\n  getRaycastTarget(camera: THREE.Camera, raycaster: THREE.Raycaster): { block: Block; face: THREE.Vector3 } | null {\n    const allMeshes: THREE.InstancedMesh[] = [];\n\n    for (const [_, chunk] of this.chunks) {\n      if (chunk.mesh) {\n        allMeshes.push(...chunk.mesh.children as THREE.InstancedMesh[]);\n      }\n    }\n\n    const intersects = raycaster.intersectObjects(allMeshes);\n\n    if (intersects.length > 0) {\n      const hit = intersects[0];\n      const matrix = new THREE.Matrix4();\n\n      const instancedMesh = hit.object as THREE.InstancedMesh;\n      const instanceId = hit.instanceId || 0;\n      instancedMesh.getMatrixAt(instanceId, matrix);\n\n      const position = new THREE.Vector3();\n      position.setFromMatrixPosition(matrix);\n\n      const chunkData = this.getChunkData(position.x, position.z);\n\n      if (chunkData) {\n        const blockKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;\n        const actualBlock = chunkData.blocks.get(blockKey);\n        if (actualBlock) {\n          return {\n            block: {\n              x: Math.round(position.x),\n              y: Math.round(position.y),\n              z: Math.round(position.z),\n              type: actualBlock.type,\n            },\n            face: hit.face.normal,\n          };\n        }\n      }\n\n      return null;\n    }\n\n  update(playerPosition: { x: number; z: number }) {\n    const cx = Math.floor(playerPosition.x / CHUNK_SIZE);\n    const cz = Math.floor(playerPosition.z / CHUNK_SIZE);\n\n    if (cx !== this.lastChunkX || cz !== this.lastChunkZ) {\n      this.lastChunkX = cx;\n      this.lastChunkZ = cz;\n\n      const renderDist = 3;\n\n      for (let dx = -renderDist; dx <= renderDist; dx++) {\n        for (let dz = -renderDist; dz <= renderDist; dz++) {\n          const key = this.getChunkKey(cx + dx, cz + dz);\n\n          if (!this.chunks.has(key)) {\n            this.generateChunk(cx + dx, cz + dz);\n          }\n        }\n      }\n\n      const keysToDelete: string[] = [];\n\n      this.chunks.forEach((chunk, key) => {\n        const [kx, kz] = key.split(',').map(Number);\n        const dist = Math.max(Math.abs(kx - cx), Math.abs(kz - cz));\n\n        if (dist > renderDist + 1) {\n          keysToDelete.push(key);\n        }\n      });\n\n      for (const key of keysToDelete) {\n        const chunk = this.chunks.get(key);\n\n        if (chunk && chunk.mesh) {\n          this.scene.remove(chunk.mesh);\n        }\n\n        this.chunks.delete(key);\n      }\n    }\n\n    return { ...this.worldStats };\n  }\n        }\n      }\n\n      const keysToDelete: string[] = [];\n\n      this.chunks.forEach((chunk, key) => {\n        const [kx, kz] = key.split(',').map(Number);\n        const dist = Math.max(Math.abs(kx - cx), Math.abs(kz - cz));\n\n        if (dist > renderDist + 1) {\n          keysToDelete.push(key);\n        }\n      });\n\n      for (const key of keysToDelete) {\n        const chunk = this.chunks.get(key);\n\n        if (chunk && chunk.mesh) {\n          this.scene.remove(chunk.mesh);\n        }\n\n        this.chunks.delete(key);\n      }\n    }\n  }\n\n  getStats(): WorldStats {\n    return { ...this.worldStats };\n  }\n\n  dispose() {\n    this.blockMaterials.forEach((materials) => {\n      materials.forEach((material) => material.dispose());\n    });\n\n    this.blockGeometries.forEach((geometry) => {\n      geometry.dispose();\n    });\n\n    this.geometry.dispose();\n\n    for (const [_, chunk] of this.chunks) {\n      if (chunk.mesh) {\n        this.scene.remove(chunk.mesh);\n      }\n    }\n\n    this.chunks.clear();\n  }\n}\n",
    "tokens": 2726
  }
]