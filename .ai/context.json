[
  {
    "type": "file",
    "path": "/Users/ygs/myworld/src/main.ts",
    "content": "import * as THREE from 'three';\nimport { Game as Game } from './chunkManager';\nimport { Player } from './player';\nimport { BLOCK_NAMES, BlockType, WORLD_SIZE, WorldStats } from './types';\n\nexport class MyWorldGame {\n  private scene: THREE.Scene;\n  private camera: THREE.PerspectiveCamera;\n  private renderer: THREE.WebGLRenderer;\n  private chunkManager: Game;\n  private player: Player;\n  private raycaster: THREE.Raycaster;\n  private selectedBlock: BlockType = 'grass';\n  private isRunning: boolean = false;\n  private lastTime: number = 0;\n  private frameCount: number = 0;\n  private lastFpsUpdate: number = 0;\n  private stats: WorldStats = {\n    blocksPlaced: 0,\n    blocksBroken: 0\n  };\n\n  constructor() {\n    this.init();\n    this.setupUI();\n    this.animate();\n  }\n\n  private init() {\n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(0x87CEEB);\n    this.scene.fog = new THREE.Fog(0x87CEEB, 50, WORLD_SIZE * 2);\n\n    this.camera = new THREE.PerspectiveCamera(\n      75,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      1000\n    );\n\n    this.renderer = new THREE.WebGLRenderer({ antialias: false });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    document.getElementById('game-container')?.appendChild(this.renderer.domElement);\n\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\n    this.scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(50, 100, 50);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 2048;\n    directionalLight.shadow.mapSize.height = 2048;\n    directionalLight.shadow.camera.near = 0.5;\n    directionalLight.shadow.camera.far = 500;\n    directionalLight.shadow.camera.left = -WORLD_SIZE;\n    directionalLight.shadow.camera.right = WORLD_SIZE;\n    directionalLight.shadow.camera.top = WORLD_SIZE;\n    directionalLight.shadow.camera.bottom = -WORLD_SIZE;\n    this.scene.add(directionalLight);\n\n    this.chunkManager = new Game(this.scene);\n\n    this.player = new Player(this.camera, { x: 0, y: 50, z: 0 });\n\n    this.raycaster = new THREE.Raycaster();\n    this.raycaster.far = 6;\n\n    window.addEventListener('resize', () => this.onWindowResize());\n    document.addEventListener('mousedown', (e) => this.onMouseDown(e));\n\n    const loading = document.getElementById('loading');\n    if (loading) loading.style.display = 'none';\n  }\n\n  private setupUI() {\n    const startBtn = document.getElementById('start-btn');\n    if (startBtn) {\n      startBtn.addEventListener('click', () => {\n        const instructions = document.getElementById('instructions');\n        if (instructions) instructions.style.display = 'none';\n        this.isRunning = true;\n        document.body.requestPointerLock();\n      });\n    }\n  }\n\n  private onMouseDown(e: MouseEvent) {\n    if (!this.isRunning) return;\n\n    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);\n    const target = this.chunkManager.getRaycastTarget(this.raycaster);\n\n    if (target) {\n      const { block, face } = target;\n\n      if (e.button === 0) {\n        this.chunkManager.removeBlock(block.x, block.y, block.z);\n      } else if (e.button === 2) {\n        const newX = block.x + Math.round(face.x);\n        const newY = block.y + Math.round(face.y);\n        const newZ = block.z + Math.round(face.z);\n\n        const playerPos = this.player.getPosition();\n        const distance = Math.sqrt(\n          Math.pow(newX - playerPos.x, 2) +\n          Math.pow(newY - (playerPos.y + 0.9), 2) +\n          Math.pow(newZ - playerPos.z, 2)\n        );\n\n        if (distance > 1.5) {\n          this.chunkManager.addBlock(newX, newY, newZ, this.selectedBlock);\n        }\n      }\n    }\n  }\n\n  private onWindowResize() {\n    this.camera.aspect = window.innerWidth / window.innerHeight;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n  private updateUI(delta: number) {\n    this.frameCount++;\n\n    if (performance.now() - this.lastFpsUpdate >= 1000) {\n      const fps = this.frameCount;\n      const fpsElement = document.getElementById('fps');\n      if (fpsElement) fpsElement.textContent = fps.toString();\n\n      this.frameCount = 0;\n      this.lastFpsUpdate = performance.now();\n    }\n\n    const pos = this.player.getPosition();\n    const stats = this.chunkManager.getStats();\n    const posElement = document.getElementById('position');\n    if (posElement) {\n      posElement.textContent = `X: ${Math.floor(pos.x)} Y: ${Math.floor(pos.y)} Z: ${Math.floor(pos.z)}`;\n    }\n\n    const statsElement = document.getElementById('stats');\n    if (statsElement) {\n      statsElement.innerHTML = `Placed: ${stats.blocksPlaced} | Broken: ${stats.blocksBroken}`;\n    }\n  }\n\n  private animate() {\n    requestAnimationFrame(() => this.animate());\n\n    const currentTime = performance.now();\n    const delta = (currentTime - this.lastTime) / 1000;\n    this.lastTime = currentTime;\n\n    if (this.isRunning) {\n      this.player.update(delta, this.chunkManager);\n      this.chunkManager.update(this.player.getPosition());\n    }\n\n    this.renderer.render(this.scene, this.camera);\n    this.updateUI(delta);\n  }\n}\n\nnew MyWorldGame();\n",
    "tokens": 1338
  },
  {
    "type": "file",
    "path": "/Users/ygs/myworld/src/player.ts",
    "content": "import * as THREE from 'three';\nimport { GRAVITY, JUMP_FORCE, MOVE_SPEED, MOUSE_SENSITIVITY, PlayerState, RUN_MULTIPLIER } from './types';\n\nexport class Player {\n  private camera: THREE.PerspectiveCamera;\n  private state: PlayerState;\n  private keys: Map<string, boolean>;\n  private isLocked: boolean;\n\n  constructor(camera: THREE.PerspectiveCamera, startPosition = { x: 0, y: 10, z: 0 }) {\n    this.camera = camera;\n    this.keys = new Map();\n    this.isLocked = false;\n\n    this.state = {\n      position: { ...startPosition },\n      rotation: { x: 0, y: 0 },\n      velocity: { x: 0, y: 0, z: 0 },\n      onGround: false,\n    };\n\n    this.setupEventListeners();\n    this.updateCamera();\n  }\n\n  private setupEventListeners() {\n    document.addEventListener('keydown', (e) => {\n      this.keys.set(e.code, true);\n\n      if (e.code === 'Space' && this.state.onGround) {\n        this.state.velocity.y = JUMP_FORCE;\n        this.state.onGround = false;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      this.keys.set(e.code, false);\n    });\n\n    document.addEventListener('mousemove', (e) => {\n      if (this.isLocked) {\n        this.state.rotation.y -= e.movementX * MOUSE_SENSITIVITY;\n        this.state.rotation.x -= e.movementY * MOUSE_SENSITIVITY;\n\n        this.state.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.state.rotation.x));\n\n        this.updateCamera();\n      }\n    });\n\n    document.addEventListener('pointerlockchange', () => {\n      this.isLocked = document.pointerLockElement === document.body;\n    });\n\n    document.addEventListener('click', () => {\n      if (!this.isLocked) {\n        document.body.requestPointerLock();\n      }\n    });\n  }\n\n  private updateCamera() {\n    this.camera.position.set(\n      this.state.position.x,\n      this.state.position.y + 1.6,\n      this.state.position.z\n    );\n\n    this.camera.rotation.order = 'YXZ';\n    this.camera.rotation.y = this.state.rotation.y;\n    this.camera.rotation.x = this.state.rotation.x;\n  }\n\n  getDirection(): THREE.Vector3 {\n    const direction = new THREE.Vector3();\n\n    if (this.keys.get('KeyW')) direction.z -= 1;\n    if (this.keys.get('KeyS')) direction.z += 1;\n    if (this.keys.get('KeyA')) direction.x -= 1;\n    if (this.keys.get('KeyD')) direction.x += 1;\n\n    direction.normalize();\n    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.state.rotation.y);\n\n    return direction;\n  }\n\n  getCurrentSpeed(): number {\n    const isSprinting = this.keys.get('ShiftLeft') || this.keys.get('ShiftRight');\n    return isSprinting ? MOVE_SPEED * RUN_MULTIPLIER : MOVE_SPEED;\n  }\n\n  update(delta: number, world: any) {\n    this.state.velocity.y += GRAVITY * delta;\n\n    const direction = this.getDirection();\n    const speed = this.getCurrentSpeed();\n    this.state.velocity.x = direction.x * speed;\n    this.state.velocity.z = direction.z * speed;\n\n    const newX = this.state.position.x + this.state.velocity.x * delta;\n    const newY = this.state.position.y + this.state.velocity.y * delta;\n    const newZ = this.state.position.z + this.state.velocity.z * delta;\n\n    if (!this.checkCollision(newX, this.state.position.y, this.state.position.z, world)) {\n      this.state.position.x = newX;\n    } else {\n      this.state.velocity.x = 0;\n    }\n\n    if (!this.checkCollision(this.state.position.x, newY, this.state.position.z, world)) {\n      this.state.position.y = newY;\n      this.state.velocity.y *= 0.99;\n    } else {\n      if (this.state.velocity.y < 0) {\n        this.state.onGround = true;\n      }\n      this.state.velocity.y = 0;\n    }\n\n    if (!this.checkCollision(this.state.position.x, this.state.position.y, newZ, world)) {\n      this.state.position.z = newZ;\n    } else {\n      this.state.velocity.z = 0;\n    }\n\n    if (this.state.position.y < -10) {\n      this.state.position.y = 10;\n      this.state.velocity.y = 0;\n    }\n\n    this.updateCamera();\n  }\n\n  private checkCollision(x: number, y: number, z: number, world: any): boolean {\n    const playerHeight = 1.8;\n    const playerRadius = 0.3;\n\n    const checkPoints = [\n      { x, y: y + 0.5, z },\n      { x, y: y + 1.0, z },\n      { x, y: y + 1.5, z },\n    ];\n\n    for (const point of checkPoints) {\n      for (let dx = -playerRadius; dx <= playerRadius; dx += playerRadius * 2) {\n        for (let dz = -playerRadius; dz <= playerRadius; dz += playerRadius * 2) {\n          const bx = Math.floor(point.x + dx);\n          const by = Math.floor(point.y);\n          const bz = Math.floor(point.z + dz);\n\n          if (world.getBlockAt(bx, by, bz)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  getPosition(): { x: number; y: number; z: number } {\n    return { ...this.state.position };\n  }\n\n  getRotation(): { x: number; y: number } {\n    return { ...this.state.rotation };\n  }\n}\n",
    "tokens": 1202
  },
  {
    "type": "file",
    "path": "/Users/ygs/myworld/src/types.ts",
    "content": "export interface Vector3Like {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface Block {\n  x: number;\n  y: number;\n  z: number;\n  type: BlockType;\n}\n\nexport type BlockType = 'grass' | 'dirt' | 'stone' | 'wood' | 'leaves' | 'sand' | 'water';\n\nexport interface BlockColor {\n  top: number;\n  side: number;\n  bottom: number;\n}\n\nexport interface WorldStats {\n  blocksPlaced: number;\n  blocksBroken: number;\n}\n\nexport interface PlayerState {\n  position: { x: number; y: number; z: number };\n  rotation: { x: number; y: number };\n  velocity: { x: number; y: number; z: number };\n  onGround: boolean;\n}\n\nexport const BLOCK_COLORS: Record<BlockType, BlockColor> = {\n  grass: { top: 0x7CFC00, side: 0x8B4513, bottom: 0x8B4513 },\n  dirt: { top: 0x8B4513, side: 0x8B4513, bottom: 0x8B4513 },\n  stone: { top: 0x808080, side: 0x808080, bottom: 0x808080 },\n  wood: { top: 0x8B6914, side: 0x654321, bottom: 0x8B6914 },\n  leaves: { top: 0x228B22, side: 0x228B22, bottom: 0x228B22 },\n  sand: { top: 0xF4A460, side: 0xF4A460, bottom: 0xF4A460 },\n  water: { top: 0x4169E1, side: 0x4169E1, bottom: 0x4169E1 },\n};\n\nexport const BLOCK_NAMES: Record<BlockType, string> = {\n  grass: '草地',\n  dirt: '泥土',\n  stone: '石头',\n  wood: '木头',\n  leaves: '树叶',\n  sand: '沙子',\n  water: '水',\n};\n\nexport const WORLD_SIZE = 32;\nexport const CHUNK_SIZE = 16;\nexport const BLOCK_SIZE = 1;\nexport const GRAVITY = -30;\nexport const JUMP_FORCE = 10;\nexport const MOVE_SPEED = 5;\nexport const RUN_MULTIPLIER = 1.5;\nexport const MOUSE_SENSITIVITY = 0.002;\n",
    "tokens": 379
  },
  {
    "type": "file",
    "path": "src/chunkManager.ts",
    "content": "import * as THREE from 'three';\nimport { BLOCK_COLORS, Block, BlockType, WorldStats, CHUNK_SIZE } from './types';\n\nexport interface ChunkKey {\n  x: number;\n  z: number;\n}\n\nexport interface ChunkData {\n  blocks: Map<string, Block>;\n  mesh?: THREE.Object3D;\n  position: { x: number; z: number };\n}\n\nexport class Game {\n  private scene: THREE.Scene;\n  private chunks: Map<string, ChunkData> = new Map();\n  private blockGeometries: Map<BlockType, THREE.BoxGeometry> = new Map();\n  private blockMaterials: Map<BlockType, THREE.Material[]> = new Map();\n  private lastChunkX: number = 0;\n  private lastChunkZ: number = 0;\n  private geometry: THREE.BoxGeometry = new THREE.BoxGeometry(1, 1, 1);\n  private worldStats: WorldStats = {\n    blocksPlaced: 0,\n    blocksBroken: 0,\n  };\n\n  constructor(scene: THREE.Scene) {\n    this.scene = scene;\n    this.createMaterials();\n    this.createBlockGeometries();\n  }\n\n  private createMaterials() {\n    this.blockMaterials = new Map();\n\n    for (const [blockType, colors] of Object.entries(BLOCK_COLORS)) {\n      const materials = [\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.top }),\n        new THREE.MeshLambertMaterial({ color: colors.bottom }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n        new THREE.MeshLambertMaterial({ color: colors.side }),\n      ];\n      this.blockMaterials.set(blockType as BlockType, materials);\n    }\n  }\n\n  private createBlockGeometries() {\n    this.blockGeometries = new Map();\n\n    const blockTypes: BlockType[] = ['grass', 'dirt', 'stone', 'wood', 'leaves', 'sand'];\n\n    for (const type of blockTypes) {\n      const geo = new THREE.BoxGeometry(1, 1, 1);\n      this.blockGeometries.set(type, geo);\n    }\n  }\n\n  private getChunkKey(cx: number, cz: number): string {\n    return `${cx},${cz}`;\n  }\n\n  getChunkData(worldX: number, worldZ: number): ChunkData | null {\n    const cx = Math.floor(worldX / CHUNK_SIZE);\n    const cz = Math.floor(worldZ / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    if (!this.chunks.has(key)) {\n      return null;\n    }\n\n    return this.chunks.get(key) || null;\n  }\n\n  addBlock(x: number, y: number, z: number, type: BlockType) {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    let chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      chunkData = {\n        blocks: new Map(),\n        position: { x: cx * CHUNK_SIZE, z: cz * CHUNK_SIZE },\n      };\n      this.chunks.set(key, chunkData);\n    }\n\n    const blockKey = `${x},${y},${z}`;\n    chunkData.blocks.set(blockKey, { x, y, z, type });\n    this.worldStats.blocksPlaced++;\n\n    this.rebuildChunkMesh(cx, cz);\n    this.updateNeighborChunks(cx, cz);\n  }\n\n  removeBlock(x: number, y: number, z: number): boolean {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n    const blockKey = `${x},${y},${z}`;\n\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData || !chunkData.blocks.has(blockKey)) {\n      return false;\n    }\n\n    chunkData.blocks.delete(blockKey);\n    this.worldStats.blocksBroken++;\n\n    this.rebuildChunkMesh(cx, cz);\n    this.updateNeighborChunks(cx, cz);\n\n    return true;\n  }\n\n  private rebuildChunkMesh(cx: number, cz: number) {\n    const key = this.getChunkKey(cx, cz);\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      return;\n    }\n\n    if (chunkData.mesh) {\n      this.scene.remove(chunkData.mesh);\n    }\n\n    const instancesByType = new Map<BlockType, { count: number; matrices: THREE.Matrix4[] }>();\n\n    for (const [_, block] of chunkData.blocks) {\n      if (!instancesByType.has(block.type)) {\n        instancesByType.set(block.type, { count: 0, matrices: [] });\n      }\n\n      const instanceData = instancesByType.get(block.type)!;\n      instanceData.count++;\n      instanceData.matrices.push(new THREE.Matrix4().makeTranslation(block.x, block.y, block.z));\n    }\n\n    const group = new THREE.Group();\n\n    for (const [blockType, data] of instancesByType) {\n      if (data.count === 0) continue;\n\n      const geometry = this.blockGeometries.get(blockType);\n      const materials = this.blockMaterials.get(blockType);\n\n      if (!geometry || !materials) continue;\n\n      const instancedMesh = new THREE.InstancedMesh(geometry, materials, data.count);\n\n      for (let i = 0; i < data.count; i++) {\n        instancedMesh.setMatrixAt(i, data.matrices[i]);\n      }\n\n      instancedMesh.instanceMatrix.needsUpdate = true;\n      instancedMesh.castShadow = true;\n      instancedMesh.receiveShadow = true;\n\n      group.add(instancedMesh);\n    }\n\n    this.scene.add(group);\n    chunkData.mesh = group;\n  }\n\n  private updateNeighborChunks(cx: number, cz: number) {\n    const directions = [\n      [1, 0], [-1, 0], [0, 1], [0, -1],\n    ];\n\n    for (const [dx, dz] of directions) {\n      const neighborKey = this.getChunkKey(cx + dx, cz + dz);\n\n      if (this.chunks.has(neighborKey)) {\n        this.rebuildChunkMesh(cx + dx, cz + dz);\n      }\n    }\n  }\n\n  private generateChunk(cx: number, cz: number) {\n    const key = this.getChunkKey(cx, cz);\n    const chunkData: ChunkData = {\n      blocks: new Map(),\n      position: { x: cx * CHUNK_SIZE, z: cz * CHUNK_SIZE },\n    };\n\n    const offsetX = cx * CHUNK_SIZE;\n    const offsetZ = cz * CHUNK_SIZE;\n\n    for (let x = 0; x < CHUNK_SIZE; x++) {\n      for (let z = 0; z < CHUNK_SIZE; z++) {\n        const wx = offsetX + x;\n        const wz = offsetZ + z;\n\n        const height = Math.floor(\n          Math.sin(wx * 0.05) * 3 +\n          Math.cos(wz * 0.05) * 3 +\n          Math.sin(wx * 0.03 + wz * 0.03) * 5 + 5\n        );\n\n        for (let y = 0; y <= height; y++) {\n          let blockType: BlockType;\n\n          if (y === height) {\n            blockType = 'grass';\n          } else if (y > height - 3) {\n            blockType = 'dirt';\n          } else {\n            blockType = 'stone';\n          }\n\n          chunkData.blocks.set(`${wx},${y},${wz}`, { x: wx, y, z: wz, type: blockType });\n        }\n\n        if (x % 8 === 0 && z % 8 === 0 && Math.random() > 0.7) {\n          this.generateTree(chunkData, wx, height + 1, wz);\n        }\n      }\n    }\n\n    this.chunks.set(key, chunkData);\n    this.rebuildChunkMesh(cx, cz);\n  }\n\n  private generateTree(chunkData: ChunkData, x: number, y: number, z: number) {\n    for (let i = 0; i < 4; i++) {\n      chunkData.blocks.set(`${x},${y + i},${z}`, { x, y: y + i, z, type: 'wood' });\n    }\n\n    for (let dx = -2; dx <= 2; dx++) {\n      for (let dz = -2; dz <= 2; dz++) {\n        for (let dy = 0; dy <= 2; dy++) {\n          if (Math.abs(dx) === 2 && Math.abs(dz) === 2) continue;\n          if (dy === 2 && (Math.abs(dx) > 1 || Math.abs(dz) > 1)) continue;\n          if (dx === 0 && dz === 0 && dy < 2) continue;\n\n          chunkData.blocks.set(`${x + dx},${y + 4 + dy},${z + dz}`, {\n            x: x + dx,\n            y: y + 4 + dy,\n            z: z + dz,\n            type: 'leaves',\n          });\n        }\n      }\n    }\n  }\n\n  getBlockAt(x: number, y: number, z: number): Block | null {\n    const cx = Math.floor(x / CHUNK_SIZE);\n    const cz = Math.floor(z / CHUNK_SIZE);\n    const key = this.getChunkKey(cx, cz);\n\n    const chunkData = this.chunks.get(key);\n\n    if (!chunkData) {\n      return null;\n    }\n\n    const blockKey = `${x},${y},${z}`;\n    return chunkData.blocks.get(blockKey) || null;\n  }\n\n  getRaycastTarget(raycaster: THREE.Raycaster): { block: Block; face: THREE.Vector3 } | null {\n    const allMeshes: THREE.InstancedMesh[] = [];\n\n    for (const [_, chunk] of this.chunks) {\n      if (chunk.mesh) {\n        allMeshes.push(...chunk.mesh.children as THREE.InstancedMesh[]);\n      }\n    }\n\n    const intersects = raycaster.intersectObjects(allMeshes);\n\n    if (intersects.length > 0) {\n      const hit = intersects[0];\n      const matrix = new THREE.Matrix4();\n\n      const instancedMesh = hit.object as THREE.InstancedMesh;\n      const instanceId = hit.instanceId || 0;\n      instancedMesh.getMatrixAt(instanceId, matrix);\n\n      const position = new THREE.Vector3();\n      position.setFromMatrixPosition(matrix);\n\n      const chunkData = this.getChunkData(position.x, position.z);\n\n      if (chunkData) {\n        const blockKey = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;\n        const actualBlock = chunkData.blocks.get(blockKey);\n        if (actualBlock) {\n          return {\n            block: {\n              x: Math.round(position.x),\n              y: Math.round(position.y),\n              z: Math.round(position.z),\n              type: actualBlock.type,\n            },\n            face: hit.face ? hit.face.normal : new THREE.Vector3(0, 1, 0),\n          };\n        }\n      }\n\n      return null;\n    }\n    return null;\n  }\n\n  update(playerPosition: { x: number; z: number }) {\n    const cx = Math.floor(playerPosition.x / CHUNK_SIZE);\n    const cz = Math.floor(playerPosition.z / CHUNK_SIZE);\n\n    if (cx !== this.lastChunkX || cz !== this.lastChunkZ) {\n      this.lastChunkX = cx;\n      this.lastChunkZ = cz;\n\n      const renderDist = 3;\n\n      for (let dx = -renderDist; dx <= renderDist; dx++) {\n        for (let dz = -renderDist; dz <= renderDist; dz++) {\n          const key = this.getChunkKey(cx + dx, cz + dz);\n\n          if (!this.chunks.has(key)) {\n            this.generateChunk(cx + dx, cz + dz);\n          }\n        }\n      }\n\n      const keysToDelete: string[] = [];\n\n      this.chunks.forEach((_, key) => {\n        const [kx, kz] = key.split(',').map(Number);\n        const dist = Math.max(Math.abs(kx - cx), Math.abs(kz - cz));\n\n        if (dist > renderDist + 1) {\n          keysToDelete.push(key);\n        }\n      });\n\n      for (const key of keysToDelete) {\n        const chunk = this.chunks.get(key);\n\n        if (chunk && chunk.mesh) {\n          this.scene.remove(chunk.mesh);\n        }\n\n        this.chunks.delete(key);\n      }\n    }\n\n    return { ...this.worldStats };\n  }\n\n  getStats(): WorldStats {\n    return { ...this.worldStats };\n  }\n\n  dispose() {\n    this.blockMaterials.forEach((materials) => {\n      materials.forEach((material) => material.dispose());\n    });\n\n    this.blockGeometries.forEach((geometry) => {\n      geometry.dispose();\n    });\n\n    this.geometry.dispose();\n\n    for (const [_, chunk] of this.chunks) {\n      if (chunk.mesh) {\n        this.scene.remove(chunk.mesh);\n      }\n    }\n\n    this.chunks.clear();\n  }\n}\n",
    "tokens": 2638
  }
]