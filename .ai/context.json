[
  {
    "type": "file",
    "path": "g.html",
    "content": "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ULW Minecraft 4.1 - Fast & Infinite</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }\n        \n        /* 准星 */\n        #crosshair {\n            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;\n            background: rgba(255,255,255,0.8);\n            clip-path: polygon(40% 0, 60% 0, 60% 40%, 100% 40%, 100% 60%, 60% 60%, 60% 100%, 40% 100%, 40% 60%, 0 60%, 0 40%, 40% 40%);\n            transform: translate(-50%, -50%); mix-blend-mode: exclusion; z-index: 100;\n        }\n\n        /* UI 层 */\n        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }\n        \n        /* 右侧背包按钮 */\n        #inv-toggle-btn {\n            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);\n            width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #fff;\n            border-radius: 10px; cursor: pointer; pointer-events: auto;\n            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;\n            transition: 0.2s;\n        }\n        #inv-toggle-btn:hover { background: rgba(0,0,0,0.8); scale: 1.1; }\n\n        /* 快捷栏 */\n        #hotbar {\n            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);\n            display: flex; gap: 8px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; pointer-events: auto;\n        }\n        .slot {\n            width: 50px; height: 50px; background: #3c3c3c; border: 3px solid #555;\n            display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer;\n            image-rendering: pixelated;\n        }\n        .slot.active { border-color: #fff; box-shadow: 0 0 8px white; transform: translateY(-2px); }\n        .slot img { width: 36px; height: 36px; image-rendering: pixelated; }\n        .slot .count { \n            position: absolute; bottom: 2px; right: 2px; color: white; \n            font-size: 14px; font-weight: bold; text-shadow: 2px 2px 0 #000; font-family: monospace;\n        }\n\n        /* 背包界面 */\n        #inventory-screen {\n            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);\n            width: 720px; height: 550px; background: #c6c6c6; border: 4px solid #333; pointer-events: auto;\n            box-shadow: 0 0 30px rgba(0,0,0,0.8); padding: 20px; border-radius: 4px;\n            color: #333;\n        }\n        \n        .panel-title { font-size: 18px; margin-bottom: 10px; font-weight: bold; border-bottom: 2px solid #777; padding-bottom: 5px; }\n\n        #crafting-area {\n            display: flex; gap: 10px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 15px;\n            background: #b0b0b0; padding: 10px; border-radius: 4px; box-shadow: inset 0 0 5px rgba(0,0,0,0.2);\n        }\n        .craft-item {\n            min-width: 64px; height: 80px; background: #8b8b8b; border: 2px solid #555; cursor: pointer;\n            display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;\n        }\n        .craft-item:hover { background: #9c9c9c; border-color: #fff; }\n        .craft-item.disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }\n\n        #inv-grid { \n            display: grid; grid-template-columns: repeat(10, 1fr); gap: 6px; \n            height: 320px; overflow-y: auto; background: #8b8b8b; padding: 10px; border: inset 3px #555;\n        }\n        \n        #stats { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 2px 2px 0 #000; font-family: monospace; }\n        \n        /* 提示 */\n        #message {\n            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);\n            font-size: 24px; color: #ffeb3b; text-shadow: 2px 2px 4px #000; \n            opacity: 0; transition: opacity 0.5s; pointer-events: none;\n        }\n    </style>\n</head>\n<body>\n\n<div id=\"crosshair\"></div>\n<div id=\"message\"></div>\n\n<div id=\"ui-layer\">\n    <div id=\"stats\">FPS: 60 | Y: 60</div>\n    <div id=\"inv-toggle-btn\" onclick=\"toggleInventory()\">背包<br>(E)</div>\n    <div id=\"hotbar\"></div>\n    <div id=\"inventory-screen\">\n        <div class=\"panel-title\">合成台 (点击图标合成)</div>\n        <div id=\"crafting-area\"></div>\n        <div class=\"panel-title\">物品栏 (64格 - 选中物品后点击快捷栏装备)</div>\n        <div id=\"inv-grid\"></div>\n        <button onclick=\"toggleInventory()\" style=\"margin-top:10px; padding:8px 30px; cursor:pointer; background:#555; color:white; border:2px solid #333;\">关闭</button>\n    </div>\n</div>\n\n<!-- Three.js 核心库 -->\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js\"></script>\n\n<script>\n    // --- 1. 游戏配置 (速度大幅提升) ---\n    const CONF = {\n        RENDER_DIST: 3,\n        CHUNK_SIZE: 16,\n        WORLD_BOTTOM: -64,\n        WORLD_TOP: 64,\n        SEA_LEVEL: 10,\n        GRAVITY: 30.0,\n        WALK_SPEED: 60.0,  // 基础行走速度提升 (原6.0)\n        RUN_SPEED: 110.0,  // 疾跑速度\n        JUMP: 13.0         // 跳跃高度略微提升\n    };\n\n    // 方块ID\n    const B = {\n        AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, BEDROCK: 4, LOG: 5, LEAVES: 6, PLANKS: 7,\n        COAL_ORE: 8, IRON_ORE: 9, DIAMOND_ORE: 10, GOLD_ORE: 11,\n        WATER: 12, LAVA: 13, SAND: 14, CRAFTING_TABLE: 15, COBBLESTONE: 16, BRICK: 17,\n        SWORD_WOOD: 100, SWORD_STONE: 101, SWORD_IRON: 102, SWORD_DIAMOND: 103, MEAT: 104\n    };\n\n    // --- 2. 纹理生成 ---\n    const iconCache = {};\n    const textures = {};\n\n    function generateTextureAndIcon(id, color, type = 'standard') {\n        const size = 64;\n        const canvas = document.createElement('canvas');\n        canvas.width = size; canvas.height = size;\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = color; ctx.fillRect(0,0,size,size);\n        for(let i=0; i<300; i++) {\n            ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n            const s = Math.ceil(Math.random()*3);\n            ctx.fillRect(Math.random()*size, Math.random()*size, s, s);\n        }\n        if(type === 'ore') {\n            ctx.fillStyle = '#000'; for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 10, 10);\n            ctx.fillStyle = color; for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 6, 6);\n            ctx.globalCompositeOperation = 'destination-over'; ctx.fillStyle = '#757575'; ctx.fillRect(0,0,size,size);\n        } else if (type === 'log') {\n            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;\n            for(let i=4; i<size; i+=10) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke(); }\n            ctx.fillStyle = '#5d4037'; ctx.fillRect(0,0,10,10);\n        } else if (type === 'brick' || type === 'cobble') {\n            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;\n            ctx.strokeRect(0,0,size,size); ctx.strokeRect(size/2, 0, size/2, size/2); ctx.strokeRect(0, size/2, size/2, size/2);\n        } else if (type === 'sword') {\n            ctx.clearRect(0,0,size,size);\n            ctx.fillStyle = '#4e342e'; ctx.fillRect(10,50, 15,15);\n            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(20,55); ctx.lineTo(55,20); ctx.lineTo(60,25); ctx.lineTo(25,60); ctx.fill();\n        } else if (type === 'meat') {\n            ctx.clearRect(0,0,size,size); ctx.fillStyle = '#e57373'; ctx.beginPath(); ctx.arc(32,32, 20, 0, Math.PI*2); ctx.fill();\n        }\n        iconCache[id] = canvas.toDataURL();\n        const tex = new THREE.CanvasTexture(canvas);\n        tex.magFilter = THREE.NearestFilter;\n        return tex;\n    }\n\n    const matCache = {};\n    const DEF = [\n        {id: B.GRASS, col:'#567d46', t:'standard'}, {id: B.DIRT, col:'#5d4037', t:'standard'},\n        {id: B.STONE, col:'#757575', t:'standard'}, {id: B.BEDROCK, col:'#111', t:'standard'},\n        {id: B.LOG, col:'#3e2723', t:'log'}, {id: B.LEAVES, col:'#2e7d32', t:'standard'},\n        {id: B.PLANKS, col:'#bcaaa4', t:'wood'}, {id: B.SAND, col:'#fff9c4', t:'standard'},\n        {id: B.WATER, col:'#2196f3', t:'standard', tr:true, op:0.6},\n        {id: B.LAVA, col:'#ff3d00', t:'standard', glow:true},\n        {id: B.COAL_ORE, col:'#212121', t:'ore'}, {id: B.IRON_ORE, col:'#d7ccc8', t:'ore'},\n        {id: B.DIAMOND_ORE, col:'#00bcd4', t:'ore'}, {id: B.GOLD_ORE, col:'#ffeb3b', t:'ore'},\n        {id: B.CRAFTING_TABLE, col:'#8d6e63', t:'brick'}, {id: B.COBBLESTONE, col:'#616161', t:'cobble'},\n        {id: B.SWORD_WOOD, col:'#8d6e63', t:'sword'}, {id: B.SWORD_STONE, col:'#757575', t:'sword'},\n        {id: B.SWORD_IRON, col:'#fff', t:'sword'}, {id: B.SWORD_DIAMOND, col:'#00bcd4', t:'sword'},\n        {id: B.MEAT, col:'#f48fb1', t:'meat'}\n    ];\n    DEF.forEach(d => {\n        const tex = generateTextureAndIcon(d.id, d.col, d.t);\n        if(d.id < 100) matCache[d.id] = new THREE.MeshLambertMaterial({ map: tex, transparent: d.tr, opacity: d.op||1, emissive: d.glow?d.col:0 });\n    });\n\n    // --- 3. 场景 ---\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x87CEEB);\n    scene.fog = new THREE.Fog(0x87CEEB, 20, CONF.RENDER_DIST * CONF.CHUNK_SIZE - 5);\n    // 增加一点 FOV 增加速度感\n    const camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer({antialias: false});\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n    scene.add(new THREE.AmbientLight(0xffffff, 0.4));\n    const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 100, 50); scene.add(sun);\n\n    // --- 4. 世界 ---\n    const worldData = {}; \n    const chunks = {};\n    const simplex = new SimplexNoise();\n\n    function getBiomeHeight(x, z) { return Math.floor(simplex.noise2D(x/100, z/100) * 20 + 30); }\n\n    function generateChunk(cx, cz) {\n        const forestNoise = (x,z) => simplex.noise2D(x/50, z/50) > 0.3;\n        for(let x=0; x<16; x++) {\n            for(let z=0; z<16; z++) {\n                const wx = cx*16 + x, wz = cz*16 + z;\n                const h = getBiomeHeight(wx, wz);\n                for(let y = CONF.WORLD_BOTTOM; y <= Math.max(h, CONF.SEA_LEVEL); y++) {\n                    let id = B.AIR;\n                    if(y === CONF.WORLD_BOTTOM) id = B.BEDROCK;\n                    else if (y < h - 4) {\n                        const cave = simplex.noise3D(wx/20, y/20, wz/20);\n                        if(cave > 0.6) id = (y < -10) ? B.LAVA : B.AIR;\n                        else {\n                            const r = Math.random();\n                            if(y<10 && r>0.99) id = B.DIAMOND_ORE;\n                            else if(y<30 && r>0.98) id = B.GOLD_ORE;\n                            else if(y<50 && r>0.97) id = B.IRON_ORE;\n                            else if(r>0.96) id = B.COAL_ORE;\n                            else id = B.STONE;\n                        }\n                    } else if (y < h) id = B.DIRT;\n                    else if (y === h) id = (y <= CONF.SEA_LEVEL) ? B.SAND : B.GRASS;\n                    else if (y <= CONF.SEA_LEVEL) id = B.WATER;\n                    if(id !== B.AIR) worldData[`${wx},${y},${wz}`] = id;\n                }\n                if(h > CONF.SEA_LEVEL && forestNoise(wx, wz) && Math.random() > 0.9) createTree(wx, h+1, wz);\n            }\n        }\n        if(Math.random() > 0.8) spawnEntity('pig', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);\n        if(Math.random() > 0.9) spawnEntity('zombie', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);\n    }\n\n    function createTree(x, y, z) {\n        for(let i=0; i<5; i++) worldData[`${x},${y+i},${z}`] = B.LOG;\n        for(let lx=-2; lx<=2; lx++) for(let lz=-2; lz<=2; lz++) for(let ly=3; ly<=5; ly++)\n            if(!worldData[`${x+lx},${y+ly},${z+lz}`]) worldData[`${x+lx},${y+ly},${z+lz}`] = B.LEAVES;\n    }\n\n    function updateChunkMesh(cx, cz) {\n        const key = `${cx},${cz}`;\n        if(chunks[key]) { scene.remove(chunks[key]); delete chunks[key]; }\n        const group = new THREE.Group();\n        const geometries = {}, matrices = {};\n        for(let x=0; x<16; x++) for(let z=0; z<16; z++) {\n            const wx = cx*16+x, wz = cz*16+z;\n            for(let y=CONF.WORLD_BOTTOM; y<=CONF.WORLD_TOP; y++) {\n                const id = worldData[`${wx},${y},${wz}`];\n                if(id && id!==B.AIR) {\n                    if(!geometries[id]) { geometries[id]=0; matrices[id]=[]; }\n                    matrices[id].push(new THREE.Matrix4().makeTranslation(wx, y, wz));\n                    geometries[id]++;\n                }\n            }\n        }\n        const boxGeo = new THREE.BoxGeometry(1,1,1);\n        for(let id in geometries) {\n            if(!matCache[id]) continue;\n            const mesh = new THREE.InstancedMesh(boxGeo, matCache[id], geometries[id]);\n            const arr = matrices[id];\n            for(let i=0; i<arr.length; i++) mesh.setMatrixAt(i, arr[i]);\n            group.add(mesh);\n        }\n        scene.add(group); chunks[key] = group;\n    }\n\n    // --- 5. 实体 ---\n    const entities = [];\n    const handGroup = new THREE.Group(); camera.add(handGroup); scene.add(camera);\n    const armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.8), new THREE.MeshLambertMaterial({color: 0xeebb99}));\n    armMesh.position.set(0.5, -0.4, -0.5); handGroup.add(armMesh);\n    const heldItemMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), matCache[B.DIRT]);\n    heldItemMesh.position.set(0.5, -0.3, -0.8); heldItemMesh.visible = false; handGroup.add(heldItemMesh);\n\n    function spawnEntity(type, x, y, z) {\n        const color = type==='zombie'?0x2e7d32 : 0xf48fb1;\n        const h = type==='zombie'?1.8:0.8;\n        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.6), new THREE.MeshLambertMaterial({color}));\n        mesh.position.set(x,y,z); scene.add(mesh);\n        entities.push({type, mesh, hp:10, vel:new THREE.Vector3(), timer:0});\n    }\n\n    // --- 6. 交互与UI ---\n    const player = { inv: new Array(64).fill(null), hotbar: [null,null,null,null,null], sel: 0 };\n    const controls = new THREE.PointerLockControls(camera, document.body);\n    const keys = {};\n    document.addEventListener('keydown', e => keys[e.code] = true);\n    document.addEventListener('keyup', e => keys[e.code] = false);\n\n    let isInvOpen = false, selectedInvIndex = -1;\n    function toggleInventory() {\n        isInvOpen = !isInvOpen;\n        document.getElementById('inventory-screen').style.display = isInvOpen ? 'block' : 'none';\n        if(isInvOpen) { controls.unlock(); renderInv(); } else controls.lock();\n    }\n\n    document.addEventListener('mousedown', e => {\n        if(isInvOpen || !controls.isLocked) { if(!isInvOpen) controls.lock(); return; }\n        handGroup.rotation.x = -0.5; setTimeout(()=>handGroup.rotation.x=0, 150);\n        if(e.button === 0) interact('break'); if(e.button === 2) interact('place');\n    });\n    \n    document.addEventListener('keydown', e => {\n        if(e.code === 'KeyE') toggleInventory();\n        if(e.key >= '1' && e.key <= '5') { player.sel = parseInt(e.key) - 1; updateHand(); renderHotbar(); }\n    });\n\n    function getLookingAt() {\n        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);\n        let pos = camera.position.clone();\n        for(let i=0; i<80; i++) {\n            pos.addScaledVector(dir, 0.06);\n            const x=Math.round(pos.x), y=Math.round(pos.y), z=Math.round(pos.z);\n            const id = worldData[`${x},${y},${z}`];\n            if(id && id!==B.AIR && id!==B.WATER) {\n                 const prev = pos.clone().addScaledVector(dir, -0.06);\n                 return {x,y,z, id, face:{x:Math.round(prev.x)-x, y:Math.round(prev.y)-y, z:Math.round(prev.z)-z}};\n            }\n        }\n        return null;\n    }\n\n    function interact(action) {\n        if(action === 'break') {\n            const hitEnt = entities.find(e => e.mesh.position.distanceTo(camera.position) < 3);\n            if(hitEnt) {\n                hitEnt.hp -= 2; hitEnt.mesh.material.emissive.setHex(0xff0000); setTimeout(()=>hitEnt.mesh.material.emissive.setHex(0), 100);\n                hitEnt.vel.y = 5; hitEnt.vel.add(new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3())).multiplyScalar(5));\n                if(hitEnt.hp<=0) { scene.remove(hitEnt.mesh); entities.splice(entities.indexOf(hitEnt),1); if(hitEnt.type==='pig') addToInv(B.MEAT, 2); }\n                return;\n            }\n        }\n        const hit = getLookingAt(); if(!hit) return;\n        if(action === 'break') {\n            if(hit.id === B.BEDROCK) return;\n            delete worldData[`${hit.x},${hit.y},${hit.z}`];\n            let drop = hit.id; if(hit.id===B.STONE) drop=B.COBBLESTONE; if(hit.id===B.GRASS) drop=B.DIRT; if(hit.id===B.LEAVES) drop=null;\n            if(drop) addToInv(drop, 1);\n            rebuild(hit.x, hit.z);\n        } else if (action === 'place') {\n            const idx = player.hotbar[player.sel]; if(idx===null || !player.inv[idx]) return;\n            const item = player.inv[idx]; if(item.id>=100) return;\n            const tx=hit.x+hit.face.x, ty=hit.y+hit.face.y, tz=hit.z+hit.face.z;\n            if(Math.abs(camera.position.x-tx)<0.6 && Math.abs(camera.position.y-ty)<1.8 && Math.abs(camera.position.z-tz)<0.6) return;\n            worldData[`${tx},${ty},${tz}`] = item.id;\n            item.count--; if(item.count<=0) player.inv[idx]=null;\n            renderHotbar(); updateHand(); rebuild(tx, tz);\n        }\n    }\n    \n    function rebuild(x, z) { updateChunkMesh(Math.floor(x/16), Math.floor(z/16)); }\n    function addToInv(id, num) {\n        for(let i=0; i<64; i++) if(player.inv[i] && player.inv[i].id===id && player.inv[i].count<64) { player.inv[i].count+=num; showMsg(`获得物品`); renderHotbar(); return; }\n        for(let i=0; i<64; i++) if(!player.inv[i]) { player.inv[i]={id, count:num}; showMsg(`获得物品`); renderHotbar(); updateHand(); return; }\n    }\n    function showMsg(m) { const el=document.getElementById('message'); el.innerText=m; el.style.opacity=1; setTimeout(()=>el.style.opacity=0,1500); }\n\n    const RECIPES = [\n        {out:B.PLANKS, n:4, in:{[B.LOG]:1}}, {out:B.CRAFTING_TABLE, n:1, in:{[B.PLANKS]:4}},\n        {out:B.SWORD_WOOD, n:1, in:{[B.PLANKS]:2}}, {out:B.SWORD_STONE, n:1, in:{[B.COBBLESTONE]:2}},\n        {out:B.SWORD_IRON, n:1, in:{[B.IRON_ORE]:2}}, {out:B.SWORD_DIAMOND, n:1, in:{[B.DIAMOND_ORE]:2}},\n        {out:B.BRICK, n:1, in:{[B.STONE]:1}}\n    ];\n    \n    function renderInv() {\n        const grid = document.getElementById('inv-grid'); grid.innerHTML='';\n        player.inv.forEach((item, i) => {\n            const el = document.createElement('div'); el.className='slot'+(selectedInvIndex===i?' active':'');\n            if(item) el.innerHTML = `<img src=\"${iconCache[item.id]}\"><span class=\"count\">${item.count}</span>`;\n            el.onclick = () => { selectedInvIndex=i; renderInv(); }; grid.appendChild(el);\n        });\n        const craft = document.getElementById('crafting-area'); craft.innerHTML='';\n        RECIPES.forEach(r => {\n            const div = document.createElement('div'); div.className='craft-item';\n            let enough = true;\n            for(let reqId in r.in) if(player.inv.reduce((s,it)=>s+(it&&it.id==reqId?it.count:0),0) < r.in[reqId]) enough=false;\n            if(!enough) div.classList.add('disabled');\n            div.innerHTML = `<img src=\"${iconCache[r.out]}\" width=\"40\"><span style=\"font-size:10px;font-weight:bold\">${r.n}</span>`;\n            div.onclick = () => {\n                if(!enough) return;\n                for(let reqId in r.in) {\n                    let cost=r.in[reqId];\n                    for(let i=0; i<64; i++) if(player.inv[i] && player.inv[i].id==reqId) {\n                        let take=Math.min(player.inv[i].count, cost); player.inv[i].count-=take; cost-=take;\n                        if(player.inv[i].count===0) player.inv[i]=null; if(cost<=0) break;\n                    }\n                }\n                addToInv(r.out, r.n); renderInv();\n            };\n            craft.appendChild(div);\n        });\n    }\n\n    function renderHotbar() {\n        const bar = document.getElementById('hotbar'); bar.innerHTML='';\n        for(let i=0; i<5; i++) {\n            const idx = player.hotbar[i]; const item = idx!==null?player.inv[idx]:null;\n            const el = document.createElement('div'); el.className='slot '+(player.sel===i?'active':'');\n            if(item) el.innerHTML = `<img src=\"${iconCache[item.id]}\"><span class=\"count\">${item.count}</span>`;\n            el.onclick=(e)=>{ e.stopPropagation(); if(isInvOpen && selectedInvIndex!==-1) { player.hotbar[i]=selectedInvIndex; selectedInvIndex=-1; renderInv(); renderHotbar(); updateHand(); } else { player.sel=i; renderHotbar(); updateHand(); }};\n            bar.appendChild(el);\n        }\n    }\n    \n    function updateHand() {\n        const idx=player.hotbar[player.sel], item=idx!==null?player.inv[idx]:null;\n        armMesh.visible = !item; heldItemMesh.visible = !!item;\n        if(item) {\n            heldItemMesh.geometry = item.id>=100 ? new THREE.BoxGeometry(0.1,0.6,0.1) : new THREE.BoxGeometry(0.4,0.4,0.4);\n            heldItemMesh.rotation.set(item.id>=100?Math.PI/4:0, 0, 0);\n            heldItemMesh.material = matCache[item.id] || new THREE.MeshBasicMaterial({color:0xffffff});\n        }\n    }\n\n    // --- 7. 循环与物理 ---\n    const clock = new THREE.Clock(); const vel = new THREE.Vector3();\n    let lastCx=-999, lastCz=-999, onGround=false;\n    camera.position.set(0, 50, 0);\n\n    function animate() {\n        requestAnimationFrame(animate);\n        const dt = Math.min(clock.getDelta(), 0.1);\n        if(controls.isLocked) {\n            vel.x -= vel.x * 10.0 * dt; vel.z -= vel.z * 10.0 * dt; vel.y -= CONF.GRAVITY * dt;\n            const dir = new THREE.Vector3();\n            const fwd = (keys['KeyW']?1:0)-(keys['KeyS']?1:0), side = (keys['KeyD']?1:0)-(keys['KeyA']?1:0);\n            dir.z = fwd; dir.x = side; dir.normalize();\n            \n            // 疾跑逻辑：按Shift加速\n            const currentSpeed = keys['ShiftLeft'] ? CONF.RUN_SPEED : CONF.WALK_SPEED;\n            if(fwd||side) { vel.z -= dir.z * currentSpeed * dt; vel.x -= dir.x * currentSpeed * dt; }\n            \n            controls.moveRight(-vel.x * dt); controls.moveForward(-vel.z * dt); camera.position.y += vel.y * dt;\n            \n            // 碰撞与自动跳跃\n            checkCollision();\n            if(keys['Space'] && onGround) vel.y = CONF.JUMP;\n            if(camera.position.y < CONF.WORLD_BOTTOM-10) { camera.position.set(0,60,0); vel.set(0,0,0); }\n        }\n\n        const cx = Math.floor(camera.position.x/16), cz = Math.floor(camera.position.z/16);\n        if(cx!==lastCx || cz!==lastCz) {\n            for(let x=-CONF.RENDER_DIST; x<=CONF.RENDER_DIST; x++) for(let z=-CONF.RENDER_DIST; z<=CONF.RENDER_DIST; z++) {\n                if(!chunks[`${cx+x},${cz+z}`]) { generateChunk(cx+x, cz+z); updateChunkMesh(cx+x, cz+z); }\n            }\n            for(let k in chunks) { const p=k.split(','); if(Math.abs(p[0]-cx)>CONF.RENDER_DIST+1 || Math.abs(p[1]-cz)>CONF.RENDER_DIST+1) { scene.remove(chunks[k]); delete chunks[k]; } }\n            lastCx=cx; lastCz=cz;\n        }\n\n        entities.forEach(ent => {\n            ent.vel.y -= CONF.GRAVITY * dt;\n            if(ent.type==='zombie' && ent.mesh.position.distanceTo(camera.position)<20) {\n                const d=camera.position.clone().sub(ent.mesh.position).normalize(); ent.vel.x=d.x*4; ent.vel.z=d.z*4;\n            } else if(Math.random()>0.98) { ent.vel.x=(Math.random()-0.5)*4; ent.vel.z=(Math.random()-0.5)*4; }\n            ent.mesh.position.addScaledVector(ent.vel, dt);\n            const ex=Math.round(ent.mesh.position.x), ey=Math.round(ent.mesh.position.y), ez=Math.round(ent.mesh.position.z);\n            if(worldData[`${ex},${ey},${ez}`] || worldData[`${ex},${ey-1},${ez}`]) { if(ent.vel.y<0) { ent.vel.y=0; ent.mesh.position.y=ey+1; } }\n        });\n\n        renderer.render(scene, camera);\n        document.getElementById('stats').innerText = `XYZ: ${Math.floor(camera.position.x)},${Math.floor(camera.position.y)},${Math.floor(camera.position.z)}`;\n    }\n\n    function checkCollision() {\n        const x=camera.position.x, y=camera.position.y, z=camera.position.z;\n        const bx=Math.round(x), by=Math.round(y-1.6), bz=Math.round(z);\n        // 自动跳跃\n        const dir=new THREE.Vector3(); camera.getWorldDirection(dir);\n        if(onGround && keys['KeyW'] && worldData[`${Math.round(x+dir.x)},${Math.round(y-1)},${Math.round(z+dir.z)}`] && !worldData[`${Math.round(x+dir.x)},${Math.round(y)},${Math.round(z+dir.z)}`]) vel.y=6;\n        \n        let hitY = -999;\n        for(let k=0; k<=2; k++) if(worldData[`${bx},${by-k},${bz}`] && worldData[`${bx},${by-k},${bz}`]!==B.AIR) { hitY=by-k; break; }\n        if(y < hitY+2.6) { camera.position.y=hitY+2.6; vel.y=0; onGround=true; } else onGround=false;\n    }\n\n    updateHand(); renderHotbar(); animate();\n    window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };\n</script>\n</body>\n</html>",
    "tokens": 6361
  }
]